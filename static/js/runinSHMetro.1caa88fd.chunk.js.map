{"version":3,"file":"static/js/runinSHMetro.1caa88fd.chunk.js","mappings":"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","sources":["svgs/mtr/line-diagram-utils.ts","svgs/railmap/methods/share.ts","svgs/railmap/methods/shmetro-coline.ts","svgs/runin/runin-shmetro.tsx"],"sourcesContent":["import { StationDict } from '../../constants/constants';\n\n/**\n * @return - negative: above main line, positive: below main line\n */\nexport const getStationYShare = (stationId: string, branches: string[][], stationList: StationDict): number => {\n    const mainBranch = branches[0];\n\n    if (mainBranch.includes(stationId)) {\n        // on main branch\n        if (branches.slice(1).find(branch => branch.includes(stationId))) {\n            // node shared by multiple branches\n            return 0;\n        } else {\n            const openJawSiblingBranch = branches.slice(1).find(branch => {\n                const isLeftOpenJaw = branch[0] === 'linestart';\n                const hasSiblingBranchOpenJawOnTheLeft =\n                    mainBranch.indexOf(stationId) < mainBranch.indexOf(branch.slice(-1)[0]);\n\n                const isRightOpenJaw = branch.slice(-1)[0] === 'lineend';\n                const hasSiblingBranchOpenJawOnTheRight = mainBranch.indexOf(stationId) > mainBranch.indexOf(branch[0]);\n\n                return (\n                    (isLeftOpenJaw && hasSiblingBranchOpenJawOnTheLeft) ||\n                    (isRightOpenJaw && hasSiblingBranchOpenJawOnTheRight)\n                );\n            });\n\n            if (openJawSiblingBranch) {\n                // on main branch but open jaw\n                // NOTE: determine y share of node by children ordering, not by whether it's a branch or not (like GZMTR)\n                // TODO: Remove requirement on stationList arg\n                return stationList[openJawSiblingBranch[0]].children.indexOf(openJawSiblingBranch[1]) === 1 ? -1 : 1;\n            } else {\n                // pure main branch without siblings or main branch with sidings\n                return 0;\n            }\n        }\n    } else {\n        // on branch/sidings\n        const branchBelongsTo = branches.slice(1).find(branch => branch.includes(stationId));\n        if (branchBelongsTo) {\n            const isSiding = branchBelongsTo[0] !== 'linestart' && branchBelongsTo.slice(-1)[0] !== 'lineend';\n            if (isSiding) {\n                return stationList[branchBelongsTo[0]].children.indexOf(branchBelongsTo[1]) === 1 ? 1.2 : -1.2;\n            } else {\n                return stationList[branchBelongsTo[0]].children.indexOf(branchBelongsTo[1]) === 1 ? 1 : -1;\n            }\n        } else {\n            // fallback\n            return 0;\n        }\n    }\n};\n\nexport const getSidingPath = (coords: [number, number][]): string => {\n    const TURNING_RADIUS = 6;\n    const RIGHT_DOWN_ARC = `a${TURNING_RADIUS},${TURNING_RADIUS},0,0,1,${TURNING_RADIUS},${TURNING_RADIUS}`;\n    const DOWN_RIGHT_ARC = `a${TURNING_RADIUS},${TURNING_RADIUS},0,0,0,${TURNING_RADIUS},${TURNING_RADIUS}`;\n    const RIGHT_UP_ARC = `a${TURNING_RADIUS},${TURNING_RADIUS},0,0,0,${TURNING_RADIUS},-${TURNING_RADIUS}`;\n    const UP_RIGHT_ARC = `a${TURNING_RADIUS},${TURNING_RADIUS},0,0,1,${TURNING_RADIUS},-${TURNING_RADIUS}`;\n\n    let prevCoord: [number, number] | undefined;\n    let paths: string[] = [];\n\n    for (let coord of coords) {\n        if (!prevCoord) {\n            paths.push('M' + coord.join(','));\n        } else {\n            if (coord[1] === prevCoord[1]) {\n                // horizontal\n                paths.push('H' + coord[0]);\n            } else {\n                const midPointX = (coord[0] + prevCoord[0]) / 2 - (prevCoord[1] === 0 ? 0 : TURNING_RADIUS * 2);\n                paths.push('H' + midPointX);\n\n                if (coord[1] > prevCoord[1]) {\n                    // turn to below\n                    paths.push(RIGHT_DOWN_ARC);\n                    paths.push('V' + (coord[1] - TURNING_RADIUS));\n                    paths.push(DOWN_RIGHT_ARC);\n                } else {\n                    // turn to above\n                    paths.push(RIGHT_UP_ARC);\n                    paths.push('V' + (coord[1] + TURNING_RADIUS));\n                    paths.push(UP_RIGHT_ARC);\n                }\n\n                paths.push('H' + coord[0]);\n            }\n        }\n        // update prev coordinate\n        prevCoord = coord;\n    }\n\n    return paths.join(' ').replace(/( H([\\d.]+))+/g, ' H$2');\n};\n","import * as Global from '../../../methods';\nimport { RMGParam, ShortDirection, StationDict, StationInfo } from '../../../constants/constants';\nimport { getSidingPath } from '../../mtr/line-diagram-utils';\n\n/**\n * Compute the adjacency list of the graph.\n * @param stnList Key-value pairs of station info\n * @param leftW Callback of left wide factor\n * @param rightW Callback of right wide factor\n */\nexport const adjacencyList = (\n    stnList: { [stnId: string]: StationInfo },\n    leftW: (stnList: { [stnId: string]: StationInfo }, stnId: string) => number,\n    rightW: (stnList: { [stnId: string]: StationInfo }, stnId: string) => number\n) => {\n    return Object.keys(stnList).reduce(\n        (acc, cur) => ({\n            ...acc,\n            [cur]: stnList[cur].children.reduce(\n                (a, c) => ({ ...a, [c]: 1 + leftW(stnList, c) + rightW(stnList, cur) }),\n                {}\n            ),\n        }),\n        {} as { [from: string]: { [to: string]: number } }\n    );\n};\n\n/**\n * Compute critical path and its length from `from` node to `to` node with critical path method.\n * @param from ID of station on the left\n * @param to ID of station on the right\n * @param adjMat Adjacency matrix in the form of `Object` returned from `adjacencyList` method.\n */\nexport const criticalPathMethod = (from: string, to: string, adjMat: ReturnType<typeof adjacencyList>) => {\n    if (from === to) {\n        return { len: 0, nodes: [from] };\n    }\n    let allLengths: number[] = [];\n    let criticalPaths: string[][] = [];\n    Object.keys(adjMat[from]).forEach(child => {\n        let cp = criticalPathMethod(child, to, adjMat);\n        if (cp.len < 0) return;\n        allLengths.push(adjMat[from][child] + cp.len);\n        cp.nodes.unshift(from);\n        criticalPaths.push(cp.nodes);\n    });\n    let maxLength = Math.max(...allLengths);\n    return {\n        len: maxLength,\n        nodes: criticalPaths[allLengths.indexOf(maxLength)],\n    };\n};\n\nexport const getXShareMTR = (stnId: string, adjMat: ReturnType<typeof adjacencyList>, branches: string[][]) => {\n    let criticalPath = criticalPathMethod('linestart', 'lineend', adjMat);\n    if (criticalPath.nodes.includes(stnId)) {\n        return criticalPathMethod(criticalPath.nodes[1], stnId, adjMat).len;\n    } else {\n        // must has 1 parent and 1 child only\n        let branchOfStn = branches.filter(branch => branch.includes(stnId))[0];\n\n        let partSource = stnId;\n        while (!criticalPath.nodes.includes(partSource)) {\n            partSource = branchOfStn[branchOfStn.indexOf(partSource) - 1];\n        }\n        let partSink = stnId;\n        while (!criticalPath.nodes.includes(partSink)) {\n            partSink = branchOfStn[branchOfStn.indexOf(partSink) + 1];\n        }\n\n        let leftOpenJaw = partSource === 'linestart';\n        let rightOpenJaw = partSink === 'lineend';\n\n        // expand to fit\n        let lens = [];\n        if (!leftOpenJaw && !rightOpenJaw) {\n            lens[0] = criticalPathMethod(criticalPath.nodes[1], partSource, adjMat).len;\n            lens[1] = criticalPathMethod(partSource, partSink, adjMat).len;\n            lens[2] = criticalPathMethod(partSource, stnId, adjMat).len;\n            lens[3] = criticalPathMethod(stnId, partSink, adjMat).len;\n        } else if (leftOpenJaw) {\n            lens[0] = 0;\n            lens[1] = criticalPathMethod(criticalPath.nodes[1], partSink, adjMat).len;\n            lens[2] = criticalPathMethod(branchOfStn[1], stnId, adjMat).len;\n            lens[3] = criticalPathMethod(stnId, partSink, adjMat).len;\n        } else {\n            // right open jaw\n            lens[0] = criticalPathMethod(criticalPath.nodes[1], partSource, adjMat).len;\n            lens[1] = criticalPathMethod(partSource, criticalPath.nodes.slice(-2)[0], adjMat).len;\n            lens[2] = criticalPathMethod(partSource, stnId, adjMat).len;\n            lens[3] = criticalPathMethod(stnId, branchOfStn.slice(-2)[0], adjMat).len;\n        }\n        return lens[0] + (lens[2] * lens[1]) / (lens[2] + lens[3]);\n    }\n};\n\nconst getYShare = (stnId: string, stnList: { [stnId: string]: StationInfo }) => {\n    return Global.getYShareMTR(stnId, stnList);\n};\n\n/**\n * Vertical position (in pixels) of station icon related to vertical position of line.\n */\nexport const getYReal = (stnId: string, param: RMGParam) => {\n    return -getYShare(stnId, param.stn_list) * param.branch_spacing;\n};\n\nconst _isPredecessor = (stnId1: string, stnId2: string, routes: string[][]) => {\n    for (let route of routes) {\n        let idx1 = route.indexOf(stnId1);\n        let idx2 = route.indexOf(stnId2);\n        if (idx2 !== -1 && idx2 < idx1) return true;\n    }\n    return false;\n};\n\nconst _isSuccessor = (stnId1: string, stnId2: string, routes: string[][]) => {\n    for (let route of routes) {\n        let idx1 = route.indexOf(stnId1);\n        let idx2 = route.indexOf(stnId2);\n        if (idx1 !== -1 && idx1 < idx2) return true;\n    }\n    return false;\n};\n\nexport const getStnState = (\n    currentId: string,\n    routes: string[][],\n    direction: 'l' | 'r'\n): { [stnId: string]: -1 | 0 | 1 } => {\n    console.log(\"computing stations' states\");\n    return [...new Set(([] as string[]).concat(...routes))].reduce(\n        (acc, cur: string) => ({\n            ...acc,\n            [cur]:\n                cur === currentId\n                    ? 0\n                    : (\n                          direction === ShortDirection.right\n                              ? _isSuccessor(currentId, cur, routes)\n                              : _isPredecessor(currentId, cur, routes)\n                      )\n                    ? 1\n                    : -1,\n        }),\n        {}\n    );\n};\n\nexport class Stations {\n    yShares = {} as { [stnId: string]: number };\n    xShares = {} as { [stnId: string]: number };\n    namePoss = {} as { [stnId: string]: boolean };\n    stnList = {} as StationDict;\n    criticalPath = {} as { len: number; nodes: string[] };\n\n    constructor(data: { stnList?: any; criticalPath?: any }) {\n        this.stnList = data.stnList;\n        this.criticalPath = data.criticalPath;\n    }\n\n    /**\n     * Increment of the weight of in-bound edge of a station, which increases the horizontal interval from its parents.\n     */\n    protected leftWideFactor = (stnId: string) => {\n        return 0;\n    };\n\n    /**\n     * Increment of the weight of out-bound edge of a station, which increases the horizontal interval from its children.\n     */\n    protected rightWideFactor = (stnId: string) => {\n        return 0;\n    };\n\n    /**\n     * Path weight from station 1 to station 2 (station 2 must be a child of station 1, otherwise return `-Infinity`).\n     */\n    public pathWeight = (stnId1: string, stnId2: string) => {\n        if (!this.stnList[stnId1].children.includes(stnId2)) {\n            return -Infinity;\n        }\n        return 1 + this.rightWideFactor(stnId1) + this.leftWideFactor(stnId2);\n    };\n\n    protected getYShare(stnId: string, branches?: string[][]): number {\n        if (stnId in this.yShares) return this.yShares[stnId];\n\n        if (\n            ['linestart', 'lineend'].includes(stnId) ||\n            this.stnList[stnId].parents.length > 1 ||\n            this.stnList[stnId].children.length > 1\n        ) {\n            this.yShares[stnId] = 0;\n            return 0;\n        }\n        var stnPred = this.stnList[stnId].parents[0];\n        if (stnPred) {\n            // parent exist\n            if (this.stnList[stnPred].children.length === 1) {\n                // no sibling, then y same as parent\n                let res = this.getYShare(stnPred);\n                this.yShares[stnId] = res;\n                return res;\n            } else {\n                // sibling exists, then y depends on its idx of being children\n                let res: 1 | -1 = this.stnList[stnPred].children.indexOf(stnId) === 0 ? 1 : -1;\n                this.yShares[stnId] = res;\n                return res;\n            }\n        } else {\n            // no parent, must be linestart\n            this.yShares[stnId] = 0;\n            return 0;\n        }\n    }\n\n    static getYShares(stnList: StationDict, branches?: string[][]) {\n        console.log('computing y shares');\n        let stations = new this({ stnList });\n\n        Object.keys(stnList).forEach(stnId => {\n            if (['linestart', 'lineend'].includes(stnId)) return;\n            if (stnId in stations.yShares) return;\n            stations.getYShare(stnId, branches);\n        });\n\n        return stations.yShares;\n    }\n\n    /**\n     * Parameters of the arcs involved in the `<path>` element.\n     */\n    private pathTurnParams = (branchSpacing: number) => {\n        let tr = 35; // turning radius\n        let dx_a = tr / 2; // dx of a\n        let dy_a = tr - dx_a * Math.sqrt(3); // dy of a\n        let dy_l = branchSpacing - 2 * dy_a; // dy of l\n        let dx_l = dy_l * Math.sqrt(3); // dx of l\n        return { tr, dx_a, dy_a, dx_l, dy_l };\n    };\n\n    /**\n     * Path segment from a station towards its southeast (lower-right).\n     */\n    private pathTurnSE = (branchSpacing: number) => {\n        let { tr, dx_a, dy_a, dx_l, dy_l } = this.pathTurnParams(branchSpacing);\n        return `a ${tr},${tr} 0 0,1 ${dx_a},${dy_a} l ${dx_l},${dy_l} a ${tr},${tr} 0 0,0 ${dx_a},${dy_a}`;\n    };\n\n    /**\n     * Path segment from a station towards its northeast (upper-right).\n     */\n    private pathTurnNE = (branchSpacing: number) => {\n        let { tr, dx_a, dy_a, dx_l, dy_l } = this.pathTurnParams(branchSpacing);\n        return `a ${tr},${tr} 0 0,0 ${dx_a},${-dy_a} l ${dx_l},${-dy_l} a ${tr},${tr} 0 0,1 ${dx_a},${-dy_a}`;\n    };\n\n    /**\n     * Generate `d` attribute of `<path>` element through all stations input.\n     */\n    protected _linePath(\n        stnIds: string[],\n        lineXs: [number, number],\n        branches: string[][],\n        realXs: { [stnId: string]: number },\n        realYs: { [stnId: string]: number },\n        branchSpacing: number,\n        cp: { len: number; nodes: string[] },\n        e: number\n    ) {\n        var [prevId, prevY, prevX] = [] as unknown as [string, number, number];\n        var path = [] as string[];\n\n        let { dx_a, dx_l } = this.pathTurnParams(branchSpacing);\n        let stnDX = dx_a + dx_l / 2;\n        let stnExtraH = ((lineXs[1] - lineXs[0]) / cp.len) * 2;\n        let stnSpareH = ((lineXs[1] - lineXs[0]) / cp.len - 2 * stnDX) / 2;\n        if (stnSpareH + stnExtraH < 0) {\n            console.warn(`SVG width too small! ${stnSpareH + stnExtraH}`);\n        }\n\n        stnIds.forEach(stnId => {\n            let x = realXs[stnId];\n            let y = realYs[stnId];\n            if (!prevY && prevY !== 0) {\n                [prevId, prevX, prevY] = [stnId, x, y];\n                if (stnIds.length === 1) {\n                    path.push(`M ${x},${y}`);\n                } else if (!branches[0].includes(stnId)) {\n                    // started from branch\n                    path.push(`M ${x},${y}`);\n                } else if (branches[0].includes(stnIds[1])) {\n                    // started from branching station, this is main line\n                    path.push(`M ${x},${y}`);\n                } else {\n                    // started form branching station, this is branch line\n                    if (realXs[stnIds[1]] > 0) {\n                        path.push(`M ${x},${y + e}`);\n                    }\n                    if (realYs[stnIds[1]] < 0) {\n                        path.push(`M ${x},${y - e}`);\n                    }\n                }\n                return;\n            }\n            if (y > prevY) {\n                path.push(\n                    y === 0\n                        ? `h ${x - prevX - stnExtraH * this.leftWideFactor(stnId) - stnSpareH - stnDX * 2}`\n                        : `h ${stnExtraH * this.rightWideFactor(prevId) + stnSpareH}`\n                );\n                path.push(this.pathTurnSE(branchSpacing));\n            } else if (y < prevY) {\n                path.push(\n                    y === 0\n                        ? `h ${x - prevX - stnExtraH * this.leftWideFactor(stnId) - stnSpareH - stnDX * 2}`\n                        : `h ${stnExtraH * this.rightWideFactor(prevId) + stnSpareH}`\n                );\n                path.push(this.pathTurnNE(branchSpacing));\n            }\n            path.push(`H ${x}`);\n            [prevId, prevX, prevY] = [stnId, x, y];\n        });\n\n        // simplify path\n        return path.join(' ').replace(/( H ([\\d.]+))+/g, ' H $2');\n    }\n\n    static drawLine(\n        branches: string[][],\n        stnStates: { [stnId: string]: -1 | 0 | 1 },\n        stnList: { [stnId: string]: StationInfo },\n        lineXs: [number, number],\n        xs: { [stnId: string]: number },\n        ys: { [stnId: string]: number },\n        branchSpacing: number,\n        cp: { len: number; nodes: string[] },\n        e: number = 0\n    ) {\n        const isMTR = this.name === 'StationsMTR';\n        let linePaths = {\n            main: [] as string[],\n            pass: [] as string[],\n            sidingMain: [] as string[],\n            sidingPass: [] as string[],\n        };\n\n        branches.forEach((branch, i) => {\n            const isSiding = branch[0] !== 'linestart' && branch.slice(-1)[0] !== 'lineend';\n\n            branch = branch.filter(stnId => !['linestart', 'lineend'].includes(stnId));\n            var lineMainStns = branch.filter(stnId => stnStates[stnId] >= 0);\n            var linePassStns = branch.filter(stnId => stnStates[stnId] <= 0);\n\n            if (lineMainStns.length === 1) {\n                linePassStns = branch;\n            }\n\n            if (lineMainStns.filter(stnId => linePassStns.indexOf(stnId) !== -1).length === 0 && lineMainStns.length) {\n                // if two set disjoint\n                if (linePassStns[0] === branch[0]) {\n                    // -1 -1 1 1\n                    linePassStns.push(lineMainStns[0]);\n                } else if (\n                    lineMainStns[0] === branch[0] &&\n                    lineMainStns[lineMainStns.length - 1] === branch[branch.length - 1] &&\n                    linePassStns.length\n                ) {\n                    linePassStns = branch;\n                    lineMainStns = [];\n                } else {\n                    // 1 1 -1 -1\n                    linePassStns.unshift(lineMainStns[lineMainStns.length - 1]);\n                }\n            }\n\n            if (isSiding && isMTR) {\n                linePaths.sidingMain.push(getSidingPath(lineMainStns.map(id => [xs[id], ys[id]])));\n                linePaths.sidingPass.push(getSidingPath(linePassStns.map(id => [xs[id], ys[id]])));\n            } else {\n                linePaths.main.push(\n                    new this({ stnList, criticalPath: cp })._linePath(\n                        lineMainStns,\n                        lineXs,\n                        branches,\n                        xs,\n                        ys,\n                        branchSpacing,\n                        cp,\n                        e\n                    )\n                );\n                linePaths.pass.push(\n                    new this({ stnList, criticalPath: cp })._linePath(\n                        linePassStns,\n                        lineXs,\n                        branches,\n                        xs,\n                        ys,\n                        branchSpacing,\n                        cp,\n                        e\n                    )\n                );\n            }\n        });\n\n        return linePaths;\n    }\n}\n\nexport const drawLine = (branch: string[], stnStates: { [stnId: string]: -1 | 0 | 1 }) => {\n    branch = branch.filter(stnId => !['linestart', 'lineend'].includes(stnId));\n    let lineMainStns = branch.filter(stnId => stnStates[stnId] >= 0);\n    let linePassStns = branch.filter(stnId => stnStates[stnId] <= 0);\n\n    if (lineMainStns.length === 1) {\n        linePassStns = branch;\n    }\n\n    if (lineMainStns.filter(stnId => linePassStns.indexOf(stnId) !== -1).length === 0 && lineMainStns.length) {\n        // if two set disjoint\n        if (linePassStns[0] === branch[0]) {\n            // -1 -1 1 1\n            linePassStns.push(lineMainStns[0]);\n        } else if (\n            lineMainStns[0] === branch[0] &&\n            lineMainStns[lineMainStns.length - 1] === branch[branch.length - 1] &&\n            linePassStns.length\n        ) {\n            linePassStns = branch;\n            lineMainStns = [];\n        } else {\n            // 1 1 -1 -1\n            linePassStns.unshift(lineMainStns[lineMainStns.length - 1]);\n        }\n    }\n\n    return {\n        main: lineMainStns,\n        pass: linePassStns,\n    };\n};\n","import { ColineInfo, InterchangeInfo } from '../../../constants/constants';\nimport { drawLine } from './share';\n\nexport interface ColineLinePath {\n    main: {\n        linePath: string[];\n        colors: InterchangeInfo[];\n    }[];\n    pass: {\n        linePath: string[];\n        colors: InterchangeInfo[];\n    }[];\n}\n\n/**\n * Return all stations from ColineInfo's `from` and `to` with coline color preserved.\n */\nexport const calculateColineStations = (colineInfoList: ColineInfo[], branches: string[][]) =>\n    colineInfoList\n        .map(coLine => {\n            const involvedBranches = branches.filter(\n                branch => branch.includes(coLine.from) && branch.includes(coLine.to)\n            );\n\n            // the current coLineInfo fall on two separate branches,\n            // which should not be possible in current design.\n            if (involvedBranches.length !== 1) return { linePath: [], colors: coLine.colors };\n\n            const branch = involvedBranches.flat();\n            const a = branch.indexOf(coLine.from);\n            const b = branch.indexOf(coLine.to);\n            const linePath = a < b ? branch.slice(a, b + 1) : branch.slice(b, a + 1);\n            return {\n                linePath: linePath,\n                colors: coLine.colors,\n            };\n        })\n        .filter(branchWithColine => branchWithColine.linePath.length !== 0);\n\n/**\n * Return coline segments with stations in main/pass order.\n */\nexport const calculateColine = (\n    branchWithColine: ReturnType<typeof calculateColineStations>,\n    stnStates: {\n        [stnId: string]: 0 | 1 | -1;\n    }\n) =>\n    branchWithColine\n        .map(branchWithColine => {\n            const linePaths = drawLine(branchWithColine.linePath, stnStates);\n            return {\n                main: [\n                    {\n                        linePath: linePaths.main,\n                        colors: branchWithColine.colors,\n                    },\n                ],\n                pass: [\n                    {\n                        linePath: linePaths.pass,\n                        colors: branchWithColine.colors,\n                    },\n                ],\n            };\n        })\n        // .map(branchWithColine =>\n        //     (\n        //         Object.entries(drawLine(branchWithColine.linePath, stnStates)) as [\n        //             keyof ReturnType<typeof drawLine>,\n        //             string[]\n        //         ][]\n        //     )\n        //         .map(([type, linePath]) => ({ [type]: { linePath: linePath, colors: branchWithColine.colors } }))\n        //         .reduce((acc, cur) => ({ ...acc, ...cur }), { main: [], pass: [] } as ColineLinePath)\n        // )\n        .reduce(\n            (acc, cur) => {\n                acc.main = [...acc.main, ...cur.main];\n                acc.pass = [...acc.pass, ...cur.pass];\n                return acc;\n            },\n            { main: [], pass: [] } as ColineLinePath\n        );\n","import React, { useMemo, memo } from 'react';\nimport { Name, StationDict } from '../../constants/constants';\nimport { useAppSelector } from '../../redux';\nimport { isColineBranch } from '../../redux/param/coline-action';\nimport { calculateColineStations } from '../railmap/methods/shmetro-coline';\n\nconst LINE_WIDTH = 12;\n\nconst RunInSHMetro = () => {\n    const { branches, routes, depsStr: deps } = useAppSelector(store => store.helper);\n    const { svg_height, current_stn_idx, direction, loop } = useAppSelector(store => store.param);\n\n    // get the height\n    const dh = svg_height - 300;\n\n    const prevStnIds = useMemo(\n        () => {\n            let prevStnIds = routes\n                .filter(route => route.includes(current_stn_idx))\n                .map(route => route[route.indexOf(current_stn_idx) + (direction === 'l' ? 1 : -1)])\n                // .flat()\n                // remove duplicate\n                .reduce((acc, cur) => (acc.includes(cur) ? acc : acc.concat(cur)), [] as string[]);\n            if (\n                loop && // if it is a loop\n                branches[0].includes(current_stn_idx) && // and this station is on the loop line\n                prevStnIds.length === 1 && // and it is the first station of that direction\n                ['linestart', 'lineend'].includes(prevStnIds[0])\n            ) {\n                // get the station from the other end\n                prevStnIds = direction === 'l' ? [branches[0][1]] : [branches[0][branches[0].length - 2]];\n            }\n            return prevStnIds;\n        },\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [deps, current_stn_idx, direction, loop]\n    );\n\n    const nextStnIds = useMemo(\n        () => {\n            let nextStnIds = routes\n                .filter(route => route.includes(current_stn_idx))\n                .map(route => route[route.indexOf(current_stn_idx) + (direction === 'l' ? -1 : 1)])\n                // .flat()\n                // remove duplicate\n                .reduce((acc, cur) => (acc.includes(cur) ? acc : acc.concat(cur)), [] as string[]);\n            if (\n                loop && // if it is a loop\n                branches[0].includes(current_stn_idx) && // and this station is on the loop line\n                nextStnIds.length === 1 && // and it is the last station of that direction\n                ['linestart', 'lineend'].includes(nextStnIds[0])\n            ) {\n                // get the station from the other end\n                nextStnIds = direction === 'l' ? [branches[0][branches[0].length - 2]] : [branches[0][1]];\n            }\n            return nextStnIds;\n        },\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [deps, current_stn_idx, direction, loop]\n    );\n\n    return (\n        <>\n            <DefsSHMetro />\n            <g transform={`translate(0,${dh})`}>\n                <GeneralStation prevStnIds={prevStnIds} nextStnIds={nextStnIds} />\n            </g>\n        </>\n    );\n};\n\nexport default RunInSHMetro;\n\nconst DefsSHMetro = memo(() => (\n    <defs>\n        {/* An extension of the line/path. Remember to minus the stroke-width.  */}\n        <marker id=\"slope\" viewBox=\"-1.5 0 3 1.5\" refY={0.5}>\n            <path d=\"M0,0L1,1H-1z\" fill=\"var(--rmg-theme-colour)\" />\n        </marker>\n\n        {/* Outline filter of white pass color in Pujiang Line */}\n        <filter\n            id=\"pujiang_outline_runin\"\n            colorInterpolationFilters=\"sRGB\"\n            // TODO: remove the absolute value while make the filter works correctly\n            filterUnits=\"userSpaceOnUse\"\n            x=\"0\"\n            y=\"-1000\"\n            width=\"5000\"\n            height=\"2000\"\n        >\n            <feMorphology operator=\"erode\" in=\"SourceAlpha\" radius=\"0\" result=\"e1\" />\n            <feMorphology operator=\"erode\" in=\"SourceAlpha\" radius=\"1\" result=\"e2\" />\n            <feComposite in=\"e1\" in2=\"e2\" operator=\"xor\" result=\"outline\" />\n            <feComposite in=\"outline\" in2=\"SourceGraphic\" operator=\"over\" result=\"output\" />\n        </filter>\n    </defs>\n));\n\ninterface RunInGeneralProps {\n    prevStnIds: string[];\n    nextStnIds: string[];\n}\n\nconst GeneralStation = (props: RunInGeneralProps) => {\n    const { prevStnIds, nextStnIds } = props;\n    const { info_panel_type, svgWidth, stn_list } = useAppSelector(store => store.param);\n\n    const middle = svgWidth.runin / 2;\n    const terminal = nextStnIds.length === 1 && ['linestart', 'lineend'].includes(nextStnIds[0]);\n    const original = prevStnIds.length === 1 && ['linestart', 'lineend'].includes(prevStnIds[0]);\n\n    const nextNames = nextStnIds.map(stnId => stn_list[stnId].name);\n    const prevNames = prevStnIds.map(stnId => stn_list[stnId].name);\n\n    const nextBranchLineDy =\n        (nextStnIds.length > 1\n            ? (nextNames[0][0].split('\\\\').length - 1) * -50 + (nextNames[0][1].split('\\\\').length - 1) * -30\n            : 0) + 10;\n    const prevBranchLineDy =\n        (prevStnIds.length > 1\n            ? (prevNames[0][0].split('\\\\').length - 1) * -50 + (prevNames[0][1].split('\\\\').length - 1) * -30\n            : 0) + 10;\n\n    return (\n        <>\n            <BranchLine\n                prevStnIds={prevStnIds}\n                nextStnIds={nextStnIds}\n                nextBranchLineDy={nextBranchLineDy}\n                prevBranchLineDy={prevBranchLineDy}\n            />\n\n            {terminal && info_panel_type !== 'sh2020' ? (\n                <TerminalStation mode=\"terminal\" prevStnIds={prevStnIds} nextStnIds={nextStnIds} />\n            ) : original && info_panel_type !== 'sh2020' ? (\n                <TerminalStation mode=\"original\" prevStnIds={prevStnIds} nextStnIds={nextStnIds} />\n            ) : (\n                <>\n                    {/* General Station */}\n                    <Line prevStnIds={prevStnIds} nextStnIds={nextStnIds} />\n\n                    <g transform={`translate(${middle},160)`} textAnchor=\"middle\">\n                        <CurrentText />\n                    </g>\n                </>\n            )}\n\n            {(original || !terminal) && <NextStn stnIds={props.nextStnIds} />}\n            {(terminal || !original) && <PrevStn stnIds={props.prevStnIds} />}\n        </>\n    );\n};\n\nconst TerminalStation = (props: { mode: 'terminal' | 'original'; prevStnIds: string[]; nextStnIds: string[] }) => {\n    const { mode, prevStnIds, nextStnIds } = props;\n    const { current_stn_idx, theme, svgWidth, direction, coline } = useAppSelector(store => store.param);\n    const { branches } = useAppSelector(store => store.helper);\n\n    const textProps = {\n        l: { original: { x: svgWidth.runin - 36, anchor: 'end' }, terminal: { x: 36, anchor: 'start' } },\n        r: { original: { x: 36, anchor: 'start' }, terminal: { x: svgWidth.runin - 36, anchor: 'end' } },\n    };\n\n    const colineStns = calculateColineStations(Object.values(coline), branches);\n    const nextColineColorFrom = mode === 'terminal' ? prevStnIds : nextStnIds;\n    const nextColineColor =\n        nextStnIds.length > 1\n            ? 'var(--rmg-theme-colour)' // BranchLine will handle color of next line well\n            : colineStns\n                  .filter(co => co.linePath.includes(current_stn_idx) && co.linePath.includes(nextColineColorFrom[0]))\n                  // TODO-coline: handle multiple coline colors\n                  .map(co => co.colors[0][2])[0] ?? 'var(--rmg-theme-colour)';\n\n    return (\n        <>\n            {mode === 'original' && (\n                <path\n                    transform={`translate(0,${coline.length ? '198' : '220'})${coline.length ? 'scale(1,2)' : ''}`}\n                    stroke={nextColineColor}\n                    strokeWidth={12}\n                    d={direction === 'l' ? `M ${svgWidth.runin - 24},16 H 36` : `M24,16 H ${svgWidth.runin - 36}`}\n                    markerEnd=\"url(#slope)\"\n                />\n            )}\n\n            {mode === 'terminal' && (\n                <g filter={theme[2] === '#999999' ? 'url(#pujiang_outline_runin)' : undefined}>\n                    <path\n                        transform={`translate(0,${coline.length ? '198' : '220'})${coline.length ? 'scale(1,2)' : ''}`}\n                        stroke=\"var(--rmg-grey)\"\n                        strokeWidth={12}\n                        d={`M24,16 H ${svgWidth.runin - 24}`}\n                    />\n                </g>\n            )}\n\n            <g\n                transform={`translate(${textProps[direction][mode].x},160)`}\n                textAnchor={textProps[direction][mode].anchor}\n            >\n                <CurrentText />\n            </g>\n        </>\n    );\n};\n\nconst Line = (props: RunInGeneralProps) => {\n    const { prevStnIds, nextStnIds } = props;\n    const {\n        direction,\n        svgWidth,\n        theme,\n        coline,\n        current_stn_idx,\n        stn_list: stnList,\n    } = useAppSelector(store => store.param);\n    const { branches } = useAppSelector(store => store.helper);\n    const middle = svgWidth.runin / 2;\n\n    // determine the end with linestart/lineend or .length === 0\n    const isEnd = (stnIds: string[]) => stnIds.includes('linestart') || stnIds.includes('lineend');\n\n    const colineStns = calculateColineStations(Object.values(coline), branches);\n\n    // whether the next line is single color(var(--rmg-theme-colour) or coline color) or multiple colors\n    // let nextColineMode: 'single' | 'multiple' = 'single';\n    // TODO-coline: if coline is allowed in other segments, then this should be considered more precisely\n    const nextColineMode =\n        nextStnIds.length > 1\n            ? // needs to be single since BranchLine is in effect\n              'single'\n            : isEnd(nextStnIds)\n            ? colineStns.filter(co => [current_stn_idx, prevStnIds[0]].every(stnId => co.linePath.includes(stnId)))\n                  .length > 0\n                ? // if this the terminal station, look back to see if it falls in coline\n                  'multiple'\n                : 'single'\n            : [current_stn_idx, nextStnIds[0]].every(stnId => branches[0].includes(stnId)) && // is in the main line\n              // and has coline from current_stn_idx to nextStnIds[0]\n              colineStns.filter(co => [current_stn_idx, nextStnIds[0]].every(stnId => co.linePath.includes(stnId)))\n                  .length > 0\n            ? 'multiple'\n            : 'single';\n\n    const nextColineColorFrom = isEnd(nextStnIds) ? prevStnIds : nextStnIds;\n    const nextColineColor =\n        nextStnIds.length > 1\n            ? 'var(--rmg-theme-colour)' // BranchLine will handle color of next line well\n            : colineStns\n                  .filter(co => co.linePath.includes(current_stn_idx) && co.linePath.includes(nextColineColorFrom[0]))\n                  // TODO-coline: handle multiple coline colors\n                  .map(co => co.colors[0][2])[0] ?? 'var(--rmg-theme-colour)';\n\n    // curr and next/pass segment is in the coline branch\n    const isInColineBranch = (\n        branches: string[][],\n        current_stn_idx: string,\n        nextOrPassStnIds: string[],\n        stnList: StationDict\n    ) =>\n        branches\n            .slice(1)\n            .filter(branch => [current_stn_idx, nextOrPassStnIds[0]].every(stnId => branch.includes(stnId)))\n            .filter(branch => isColineBranch(branch, stnList)).length > 0;\n\n    // change color to coline color only if it has coline and the curr and next stations are in the coline branch\n    const nextColor =\n        Object.keys(coline).length > 0 && isInColineBranch(branches, current_stn_idx, nextStnIds, stnList)\n            ? nextColineColor\n            : 'var(--rmg-theme-colour)';\n\n    // stretch the next line element if curr and next stations aren't in main line with coline\n    const nextLineStretch =\n        Object.keys(coline).length > 0 &&\n        nextStnIds.length === 1 && // BranchLine will add branch next line so no stretch is needed\n        (isEnd(prevStnIds) || isEnd(nextStnIds)\n            ? true // terminal station with coline(prevent linestart/lineend)\n            : !(\n                  [current_stn_idx, nextStnIds[0]].every(stnId => branches[0].includes(stnId)) &&\n                  colineStns.filter(co => co.linePath.includes(current_stn_idx) && co.linePath.includes(nextStnIds[0]))\n                      .length !== 0\n              )); // no stretch if it is in main line with coline\n\n    // stretch the pass line element if BranchLine is not in effect\n    const passLineStretch = Object.keys(coline).length > 0 && prevStnIds.length === 1;\n\n    return (\n        <g transform=\"translate(0,220)\" strokeWidth={12}>\n            <>\n                {nextColor !== 'var(--rmg-theme-colour)' && (\n                    <marker id={`slope_${nextColor}`} viewBox=\"-1.5 0 3 1.5\" refY={0.5}>\n                        <path d=\"M0,0L1,1H-1z\" fill={nextColor} />\n                    </marker>\n                )}\n                <path\n                    stroke={nextColor}\n                    d={`M ${middle},16 H ${direction === 'l' ? 36 : svgWidth.runin - 36}`}\n                    // markerEnd=\"url(#slope)\"\n                    markerEnd={nextColor === 'var(--rmg-theme-colour)' ? 'url(#slope)' : `url(#slope_${nextColor})`}\n                    transform={nextLineStretch ? 'translate(0,-22)scale(1,2)' : undefined}\n                />\n            </>\n            {nextColineMode === 'multiple' && (\n                <>\n                    <marker id={`slope_${nextColineColor}`} viewBox=\"-1.5 0 3 1.5\" refY={0.5}>\n                        <path d=\"M0,0L1,1H-1z\" fill={nextColineColor} />\n                    </marker>\n                    <path\n                        stroke={nextColineColor}\n                        d={`M ${middle},16 H ${\n                            direction === 'l' ? 36 + LINE_WIDTH : svgWidth.runin - (36 + LINE_WIDTH)\n                        }`}\n                        markerEnd={`url(#slope_${nextColineColor})`}\n                        transform=\"translate(0,-12)\"\n                    />\n                </>\n            )}\n\n            <g\n                filter={theme[2] === '#999999' ? 'url(#pujiang_outline_runin)' : undefined}\n                transform={`translate(0,${passLineStretch ? -22 : 0})scale(1,${passLineStretch ? 2 : 1})`}\n            >\n                <path\n                    stroke=\"var(--rmg-grey)\"\n                    d={`M ${middle},16 H ${direction === 'l' ? svgWidth.runin - 24 : 24} `}\n                />\n            </g>\n        </g>\n    );\n};\n\ninterface RunInBranchLineProps {\n    prevStnIds: string[];\n    nextStnIds: string[];\n    nextBranchLineDy: number;\n    prevBranchLineDy: number;\n}\n\nconst BranchLine = (props: RunInBranchLineProps) => {\n    const { prevStnIds, nextStnIds, nextBranchLineDy, prevBranchLineDy } = props;\n\n    const { direction, svgWidth, current_stn_idx, coline, theme } = useAppSelector(store => store.param);\n    const { branches } = useAppSelector(store => store.helper);\n    const middle = svgWidth.runin / 2;\n\n    const LINE_BRANCH_Y = 125;\n\n    // draw a line between these dots\n    const dotToPos = (dot: [number, number]) => `${dot[0]},${dot[1]}`;\n    const dotsToPath = (dots: [number, number][]) =>\n        `M${dotToPos(dots.at(0)!)} ` +\n        dots\n            .slice(1)\n            .map(dot => `L${dotToPos(dot)}`)\n            .join(' ');\n\n    let nextDots = (\n        direction === 'l'\n            ? [\n                  [svgWidth.runin / 3, LINE_BRANCH_Y],\n                  [svgWidth.runin / 6, nextBranchLineDy],\n                  [36, nextBranchLineDy],\n              ]\n            : [\n                  [(svgWidth.runin / 3) * 2, LINE_BRANCH_Y],\n                  [(svgWidth.runin / 6) * 5, nextBranchLineDy],\n                  [svgWidth.runin - 36, nextBranchLineDy],\n              ]\n    ) as [number, number][];\n    let prevDots = (\n        direction === 'l'\n            ? [\n                  [(svgWidth.runin / 3) * 2, LINE_BRANCH_Y],\n                  [(svgWidth.runin / 6) * 5, prevBranchLineDy],\n                  [svgWidth.runin - 24, prevBranchLineDy],\n              ]\n            : [\n                  [svgWidth.runin / 3, LINE_BRANCH_Y],\n                  [svgWidth.runin / 6, prevBranchLineDy],\n                  [24, prevBranchLineDy],\n              ]\n    ) as [number, number][];\n\n    let nextColor = 'var(--rmg-theme-colour)';\n\n    if (Object.keys(coline).length > 0) {\n        const colineStns = calculateColineStations(Object.values(coline), branches);\n\n        // If the next stns have coline branch here,\n        // uplift branch a little bit with coline color.\n        if (\n            nextStnIds.length > 1 &&\n            colineStns.filter(\n                stns =>\n                    stns.linePath.includes(current_stn_idx) && nextStnIds.some(stnId => stns.linePath.includes(stnId))\n            )\n        ) {\n            // no idea why strokeWidth is 12 but only when dy = -11 will be perfect\n            nextDots[0][1] -= LINE_WIDTH - 1;\n            nextDots.unshift([middle, LINE_BRANCH_Y - LINE_WIDTH + 1]);\n            nextColor = colineStns\n                .filter(\n                    stns =>\n                        stns.linePath.includes(current_stn_idx) &&\n                        nextStnIds.some(stnId => stns.linePath.includes(stnId))\n                )\n                // TODO-coline: known undefined issues when coline is removed if the station is removed via removeInvalidColineOnRemoveStation\n                .at(0)!\n                .colors.at(0)![2];\n        }\n\n        // If the prev stns have coline branch here,\n        // uplift branch a little bit.\n        if (\n            prevStnIds.length > 1 &&\n            colineStns.filter(\n                stns =>\n                    stns.linePath.includes(current_stn_idx) && prevStnIds.some(stnId => stns.linePath.includes(stnId))\n            )\n        ) {\n            // no idea why strokeWidth is 12 but only when dy = -11 will be perfect\n            prevDots[0][1] -= LINE_WIDTH - 1;\n            prevDots.unshift([middle, LINE_BRANCH_Y - LINE_WIDTH + 1]);\n        }\n    }\n\n    return (\n        <g\n            transform=\"translate(0,110)\"\n            strokeWidth={12}\n            fill=\"none\"\n            filter={theme[2] === '#999999' ? 'url(#pujiang_outline_runin)' : undefined}\n        >\n            {/* An extension of the line/path with coline color. */}\n            <marker id=\"slope_branch\" viewBox=\"-1.5 0 3 1.5\" refY={0.5}>\n                <path d=\"M0,0L1,1H-1z\" fill={nextColor} />\n            </marker>\n\n            {nextStnIds.length > 1 && (\n                <path stroke={nextColor} d={dotsToPath(nextDots)} markerEnd=\"url(#slope_branch)\" />\n            )}\n            {prevStnIds.length > 1 && <path stroke=\"var(--rmg-grey)\" d={dotsToPath(prevDots)} />}\n        </g>\n    );\n};\n\nconst CurrentText = () => {\n    const param = useAppSelector(store => store.param);\n    const { name } = param.stn_list[param.current_stn_idx];\n    return useMemo(\n        () => (\n            <>\n                <text className=\"rmg-name__zh\" fontSize={112}>\n                    {name[0]}\n                </text>\n                <text className=\"rmg-name__en\" fontSize={36} dy={50}>\n                    {name[1].replace('\\\\', ' ')}\n                </text>\n            </>\n        ),\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [...name]\n    );\n};\n\nconst NextText = (props: { nextName: Name } & React.SVGProps<SVGGElement>) => {\n    const { nextName, ...others } = props;\n    return (\n        <g {...others}>\n            {useMemo(\n                () => (\n                    <>\n                        {nextName[0].split('\\\\').map((name, i, array) => (\n                            <text\n                                className=\"rmg-name__zh\"\n                                fontSize={48}\n                                key={name}\n                                dy={(array.length - 1 - i) * -50 - (nextName[1].split('\\\\').length - 1) * 30}\n                            >\n                                {name}\n                            </text>\n                        ))}\n                        {nextName[1].split('\\\\').map((name, i, array) => (\n                            <text\n                                className=\"rmg-name__en\"\n                                fontSize={24}\n                                key={name}\n                                dy={28 + (array.length - 1 - i) * -30}\n                            >\n                                {name}\n                            </text>\n                        ))}\n                    </>\n                ),\n                // eslint-disable-next-line react-hooks/exhaustive-deps\n                [...nextName]\n            )}\n        </g>\n    );\n};\n\nconst PrevStn = (props: { stnIds: string[] }) => {\n    const param = useAppSelector(store => store.param);\n    const nextNames = props.stnIds.map(stnId => param.stn_list[stnId].name);\n    const prevHintDy =\n        (props.stnIds.length > 1 ? 15 : 125) +\n        nextNames.map(name => name[0].split('\\\\').length).reduce((acc, cur) => acc + cur, -nextNames.length) * -50 +\n        nextNames.map(name => name[1].split('\\\\').length).reduce((acc, cur) => acc + cur, -nextNames.length) * -30;\n    const nextBranchTextDy =\n        (props.stnIds.length > 1\n            ? (nextNames[0][0].split('\\\\').length - 1) * -50 + (nextNames[0][1].split('\\\\').length - 1) * -30\n            : 0) + 70;\n\n    return (\n        <g\n            fill=\"gray\"\n            textAnchor={param.direction === 'l' ? 'end' : 'start'}\n            transform={`translate(${param.direction === 'l' ? param.svgWidth.runin - 36 : 36},0)`}\n        >\n            <NextText nextName={nextNames[0]} transform=\"translate(0,183)\" />\n            {props.stnIds.length > 1 && (\n                <NextText nextName={nextNames[1]} transform={`translate(0,${nextBranchTextDy})`} />\n            )}\n            <g transform={`translate(0, ${prevHintDy})`}>\n                <text className=\"rmg-name__zh\" fontSize={22}>\n                    \n                </text>\n                <text className=\"rmg-name__en\" fontSize={12} dx={param.direction === 'l' ? -70 : 70}>\n                    Past Stop\n                </text>\n            </g>\n        </g>\n    );\n};\n\nconst NextStn = (props: { stnIds: string[] }) => {\n    const param = useAppSelector(store => store.param);\n    const nextNames = props.stnIds.map(stnId => param.stn_list[stnId].name);\n    const nextHintDy =\n        (props.stnIds.length > 1 ? 15 : 125) +\n        nextNames.map(name => name[0].split('\\\\').length).reduce((acc, cur) => acc + cur, -nextNames.length) * -50 +\n        nextNames.map(name => name[1].split('\\\\').length).reduce((acc, cur) => acc + cur, -nextNames.length) * -30;\n    const nextBranchTextDy =\n        (props.stnIds.length > 1\n            ? (nextNames[0][0].split('\\\\').length - 1) * -50 + (nextNames[0][1].split('\\\\').length - 1) * -30\n            : 0) + 70;\n\n    return (\n        <g\n            textAnchor={param.direction === 'l' ? 'start' : 'end'}\n            transform={`translate(${param.direction === 'l' ? 36 : param.svgWidth.runin - 36},0)`}\n        >\n            <NextText nextName={param.stn_list[props.stnIds[0]].name} transform=\"translate(0,183)\" />\n            {props.stnIds.length > 1 && (\n                <NextText\n                    nextName={param.stn_list[props.stnIds[1]].name}\n                    transform={`translate(0,${nextBranchTextDy})`}\n                />\n            )}\n            <g transform={`translate(0, ${nextHintDy})`}>\n                <text className=\"rmg-name__zh\" fontSize={22}>\n                    \n                </text>\n                <text className=\"rmg-name__en\" fontSize={12} dx={param.direction === 'l' ? 70 : -70}>\n                    Next Stop\n                </text>\n            </g>\n        </g>\n    );\n};\n"],"names":["getStationYShare","stationId","branches","stationList","mainBranch","includes","slice","find","branch","openJawSiblingBranch","isLeftOpenJaw","hasSiblingBranchOpenJawOnTheLeft","indexOf","isRightOpenJaw","hasSiblingBranchOpenJawOnTheRight","children","branchBelongsTo","getSidingPath","coords","prevCoord","RIGHT_DOWN_ARC","DOWN_RIGHT_ARC","RIGHT_UP_ARC","UP_RIGHT_ARC","paths","coord","push","midPointX","TURNING_RADIUS","join","replace","adjacencyList","stnList","leftW","rightW","Object","keys","reduce","acc","cur","a","c","criticalPathMethod","from","to","adjMat","len","nodes","allLengths","criticalPaths","forEach","child","cp","unshift","maxLength","Math","max","getXShareMTR","stnId","criticalPath","branchOfStn","filter","partSource","partSink","leftOpenJaw","lens","getStnState","currentId","routes","direction","console","log","Set","concat","ShortDirection","stnId1","stnId2","route","idx1","idx2","_isSuccessor","_isPredecessor","Stations","data","yShares","xShares","namePoss","leftWideFactor","rightWideFactor","pathWeight","Infinity","pathTurnParams","branchSpacing","dy_a","tr","sqrt","dy_l","dx_a","dx_l","pathTurnSE","pathTurnNE","this","parents","length","stnPred","res","getYShare","stnIds","lineXs","realXs","realYs","e","prevId","prevY","prevX","path","stnDX","stnExtraH","stnSpareH","warn","x","y","stations","stnStates","xs","ys","isMTR","name","linePaths","main","pass","sidingMain","sidingPass","i","isSiding","lineMainStns","linePassStns","map","id","_linePath","drawLine","calculateColineStations","colineInfoList","coLine","involvedBranches","linePath","colors","flat","b","branchWithColine","calculateColine","useAppSelector","store","helper","deps","depsStr","param","svg_height","current_stn_idx","loop","dh","prevStnIds","useMemo","nextStnIds","DefsSHMetro","transform","GeneralStation","memo","viewBox","refY","d","fill","colorInterpolationFilters","filterUnits","width","height","operator","in","radius","result","in2","props","info_panel_type","svgWidth","stn_list","middle","runin","terminal","original","nextNames","prevNames","nextBranchLineDy","split","prevBranchLineDy","BranchLine","TerminalStation","mode","Line","textAnchor","CurrentText","NextStn","PrevStn","theme","coline","textProps","l","anchor","r","colineStns","values","nextColineColorFrom","nextColineColor","co","stroke","strokeWidth","markerEnd","undefined","isEnd","nextColineMode","every","nextColor","nextOrPassStnIds","isColineBranch","isInColineBranch","nextLineStretch","passLineStretch","LINE_BRANCH_Y","dotToPos","dot","dotsToPath","dots","at","nextDots","prevDots","stns","some","LINE_WIDTH","className","fontSize","dy","NextText","nextName","others","array","prevHintDy","nextBranchTextDy","dx","nextHintDy"],"sourceRoot":""}