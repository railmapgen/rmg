{"version":3,"file":"static/js/runinSHMetro.8d7f64b5.chunk.js","mappings":"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","sources":["svgs/railmap/methods/share.ts","svgs/railmap/methods/shmetro-coline.ts","svgs/runin/runin-shmetro.tsx","svgs/svg-wrapper.tsx","../javascript/esm|/home/runner/work/rmg/rmg/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js"],"sourcesContent":["import { ShortDirection, StationDict, StationInfo } from '../../../constants/constants';\n\n/**\n * Compute the adjacency list of the graph.\n * @param stnList Key-value pairs of station info\n * @param leftW Callback of left wide factor\n * @param rightW Callback of right wide factor\n */\nexport const adjacencyList = (\n    stnList: { [stnId: string]: StationInfo },\n    leftW: (stnList: { [stnId: string]: StationInfo }, stnId: string) => number,\n    rightW: (stnList: { [stnId: string]: StationInfo }, stnId: string) => number\n) => {\n    return Object.keys(stnList).reduce(\n        (acc, cur) => ({\n            ...acc,\n            [cur]: stnList[cur].children.reduce(\n                (a, c) => ({ ...a, [c]: 1 + leftW(stnList, c) + rightW(stnList, cur) }),\n                {}\n            ),\n        }),\n        {} as { [from: string]: { [to: string]: number } }\n    );\n};\n\n/**\n * Compute critical path and its length from `from` node to `to` node with critical path method.\n * @param from ID of station on the left\n * @param to ID of station on the right\n * @param adjMat Adjacency matrix in the form of `Object` returned from `adjacencyList` method.\n */\nexport const criticalPathMethod = (from: string, to: string, adjMat: ReturnType<typeof adjacencyList>) => {\n    if (from === to) {\n        return { len: 0, nodes: [from] };\n    }\n    let allLengths: number[] = [];\n    let criticalPaths: string[][] = [];\n    Object.keys(adjMat[from]).forEach(child => {\n        let cp = criticalPathMethod(child, to, adjMat);\n        if (cp.len < 0) return;\n        allLengths.push(adjMat[from][child] + cp.len);\n        cp.nodes.unshift(from);\n        criticalPaths.push(cp.nodes);\n    });\n    let maxLength = Math.max(...allLengths);\n    return {\n        len: maxLength,\n        nodes: criticalPaths[allLengths.indexOf(maxLength)],\n    };\n};\n\nexport const getXShareMTR = (stnId: string, adjMat: ReturnType<typeof adjacencyList>, branches: string[][]) => {\n    let criticalPath = criticalPathMethod('linestart', 'lineend', adjMat);\n    if (criticalPath.nodes.includes(stnId)) {\n        return criticalPathMethod(criticalPath.nodes[1], stnId, adjMat).len;\n    } else {\n        // must has 1 parent and 1 child only\n        let branchOfStn = branches.filter(branch => branch.includes(stnId))[0];\n\n        let partSource = stnId;\n        while (!criticalPath.nodes.includes(partSource)) {\n            partSource = branchOfStn[branchOfStn.indexOf(partSource) - 1];\n        }\n        let partSink = stnId;\n        while (!criticalPath.nodes.includes(partSink)) {\n            partSink = branchOfStn[branchOfStn.indexOf(partSink) + 1];\n        }\n\n        let leftOpenJaw = partSource === 'linestart';\n        let rightOpenJaw = partSink === 'lineend';\n\n        // expand to fit\n        let lens = [];\n        if (!leftOpenJaw && !rightOpenJaw) {\n            lens[0] = criticalPathMethod(criticalPath.nodes[1], partSource, adjMat).len;\n            lens[1] = criticalPathMethod(partSource, partSink, adjMat).len;\n            lens[2] = criticalPathMethod(partSource, stnId, adjMat).len;\n            lens[3] = criticalPathMethod(stnId, partSink, adjMat).len;\n        } else if (leftOpenJaw) {\n            lens[0] = 0;\n            lens[1] = criticalPathMethod(criticalPath.nodes[1], partSink, adjMat).len;\n            lens[2] = criticalPathMethod(branchOfStn[1], stnId, adjMat).len;\n            lens[3] = criticalPathMethod(stnId, partSink, adjMat).len;\n        } else {\n            // right open jaw\n            lens[0] = criticalPathMethod(criticalPath.nodes[1], partSource, adjMat).len;\n            lens[1] = criticalPathMethod(partSource, criticalPath.nodes.slice(-2)[0], adjMat).len;\n            lens[2] = criticalPathMethod(partSource, stnId, adjMat).len;\n            lens[3] = criticalPathMethod(stnId, branchOfStn.slice(-2)[0], adjMat).len;\n        }\n        return lens[0] + (lens[2] * lens[1]) / (lens[2] + lens[3]);\n    }\n};\n\nconst _isPredecessor = (stnId1: string, stnId2: string, routes: string[][]) => {\n    for (let route of routes) {\n        let idx1 = route.indexOf(stnId1);\n        let idx2 = route.indexOf(stnId2);\n        if (idx2 !== -1 && idx2 < idx1) return true;\n    }\n    return false;\n};\n\nconst _isSuccessor = (stnId1: string, stnId2: string, routes: string[][]) => {\n    for (let route of routes) {\n        let idx1 = route.indexOf(stnId1);\n        let idx2 = route.indexOf(stnId2);\n        if (idx1 !== -1 && idx1 < idx2) return true;\n    }\n    return false;\n};\n\nexport const getStnState = (\n    currentId: string,\n    routes: string[][],\n    direction: 'l' | 'r'\n): { [stnId: string]: -1 | 0 | 1 } => {\n    console.log(\"computing stations' states\");\n    return [...new Set(([] as string[]).concat(...routes))].reduce(\n        (acc, cur: string) => ({\n            ...acc,\n            [cur]:\n                cur === currentId\n                    ? 0\n                    : (\n                          direction === ShortDirection.right\n                              ? _isSuccessor(currentId, cur, routes)\n                              : _isPredecessor(currentId, cur, routes)\n                      )\n                    ? 1\n                    : -1,\n        }),\n        {}\n    );\n};\n\nexport class Stations {\n    yShares = {} as { [stnId: string]: number };\n    xShares = {} as { [stnId: string]: number };\n    namePoss = {} as { [stnId: string]: boolean };\n    stnList = {} as StationDict;\n    criticalPath = {} as { len: number; nodes: string[] };\n\n    constructor(data: { stnList?: any; criticalPath?: any }) {\n        this.stnList = data.stnList;\n        this.criticalPath = data.criticalPath;\n    }\n\n    /**\n     * Increment of the weight of in-bound edge of a station, which increases the horizontal interval from its parents.\n     */\n    protected leftWideFactor = (stnId: string) => {\n        return 0;\n    };\n\n    /**\n     * Increment of the weight of out-bound edge of a station, which increases the horizontal interval from its children.\n     */\n    protected rightWideFactor = (stnId: string) => {\n        return 0;\n    };\n\n    protected getYShare(stnId: string, branches?: string[][]): number {\n        if (stnId in this.yShares) return this.yShares[stnId];\n\n        if (\n            ['linestart', 'lineend'].includes(stnId) ||\n            this.stnList[stnId].parents.length > 1 ||\n            this.stnList[stnId].children.length > 1\n        ) {\n            this.yShares[stnId] = 0;\n            return 0;\n        }\n        var stnPred = this.stnList[stnId].parents[0];\n        if (stnPred) {\n            // parent exist\n            if (this.stnList[stnPred].children.length === 1) {\n                // no sibling, then y same as parent\n                let res = this.getYShare(stnPred);\n                this.yShares[stnId] = res;\n                return res;\n            } else {\n                // sibling exists, then y depends on its idx of being children\n                let res: 1 | -1 = this.stnList[stnPred].children.indexOf(stnId) === 0 ? 1 : -1;\n                this.yShares[stnId] = res;\n                return res;\n            }\n        } else {\n            // no parent, must be linestart\n            this.yShares[stnId] = 0;\n            return 0;\n        }\n    }\n\n    static getYShares(stnList: StationDict, branches?: string[][]) {\n        console.log('computing y shares');\n        let stations = new this({ stnList });\n\n        Object.keys(stnList).forEach(stnId => {\n            if (['linestart', 'lineend'].includes(stnId)) return;\n            if (stnId in stations.yShares) return;\n            stations.getYShare(stnId, branches);\n        });\n\n        return stations.yShares;\n    }\n\n    /**\n     * Parameters of the arcs involved in the `<path>` element.\n     */\n    private pathTurnParams = (branchSpacing: number) => {\n        let tr = 35; // turning radius\n        let dx_a = tr / 2; // dx of a\n        let dy_a = tr - dx_a * Math.sqrt(3); // dy of a\n        let dy_l = branchSpacing - 2 * dy_a; // dy of l\n        let dx_l = dy_l * Math.sqrt(3); // dx of l\n        return { tr, dx_a, dy_a, dx_l, dy_l };\n    };\n\n    /**\n     * Path segment from a station towards its southeast (lower-right).\n     */\n    private pathTurnSE = (branchSpacing: number) => {\n        let { tr, dx_a, dy_a, dx_l, dy_l } = this.pathTurnParams(branchSpacing);\n        return `a ${tr},${tr} 0 0,1 ${dx_a},${dy_a} l ${dx_l},${dy_l} a ${tr},${tr} 0 0,0 ${dx_a},${dy_a}`;\n    };\n\n    /**\n     * Path segment from a station towards its northeast (upper-right).\n     */\n    private pathTurnNE = (branchSpacing: number) => {\n        let { tr, dx_a, dy_a, dx_l, dy_l } = this.pathTurnParams(branchSpacing);\n        return `a ${tr},${tr} 0 0,0 ${dx_a},${-dy_a} l ${dx_l},${-dy_l} a ${tr},${tr} 0 0,1 ${dx_a},${-dy_a}`;\n    };\n\n    /**\n     * Generate `d` attribute of `<path>` element through all stations input.\n     */\n    protected _linePath(\n        stnIds: string[],\n        lineXs: [number, number],\n        branches: string[][],\n        realXs: { [stnId: string]: number },\n        realYs: { [stnId: string]: number },\n        branchSpacing: number,\n        cp: { len: number; nodes: string[] },\n        e: number\n    ) {\n        var [prevId, prevY, prevX] = [] as unknown as [string, number, number];\n        var path = [] as string[];\n\n        let { dx_a, dx_l } = this.pathTurnParams(branchSpacing);\n        let stnDX = dx_a + dx_l / 2;\n        let stnExtraH = ((lineXs[1] - lineXs[0]) / cp.len) * 2;\n        let stnSpareH = ((lineXs[1] - lineXs[0]) / cp.len - 2 * stnDX) / 2;\n        if (stnSpareH + stnExtraH < 0) {\n            console.warn(`SVG width too small! ${stnSpareH + stnExtraH}`);\n        }\n\n        stnIds.forEach(stnId => {\n            let x = realXs[stnId];\n            let y = realYs[stnId];\n            if (!prevY && prevY !== 0) {\n                [prevId, prevX, prevY] = [stnId, x, y];\n                if (stnIds.length === 1) {\n                    path.push(`M ${x},${y}`);\n                } else if (!branches[0].includes(stnId)) {\n                    // started from branch\n                    path.push(`M ${x},${y}`);\n                } else if (branches[0].includes(stnIds[1])) {\n                    // started from branching station, this is main line\n                    path.push(`M ${x},${y}`);\n                } else {\n                    // started form branching station, this is branch line\n                    if (realXs[stnIds[1]] > 0) {\n                        path.push(`M ${x},${y + e}`);\n                    }\n                    if (realYs[stnIds[1]] < 0) {\n                        path.push(`M ${x},${y - e}`);\n                    }\n                }\n                return;\n            }\n            if (y > prevY) {\n                path.push(\n                    y === 0\n                        ? `h ${x - prevX - stnExtraH * this.leftWideFactor(stnId) - stnSpareH - stnDX * 2}`\n                        : `h ${stnExtraH * this.rightWideFactor(prevId) + stnSpareH}`\n                );\n                path.push(this.pathTurnSE(branchSpacing));\n            } else if (y < prevY) {\n                path.push(\n                    y === 0\n                        ? `h ${x - prevX - stnExtraH * this.leftWideFactor(stnId) - stnSpareH - stnDX * 2}`\n                        : `h ${stnExtraH * this.rightWideFactor(prevId) + stnSpareH}`\n                );\n                path.push(this.pathTurnNE(branchSpacing));\n            }\n            path.push(`H ${x}`);\n            [prevId, prevX, prevY] = [stnId, x, y];\n        });\n\n        // simplify path\n        return path.join(' ').replace(/( H ([\\d.]+))+/g, ' H $2');\n    }\n}\n\nexport const drawLine = (branch: string[], stnStates: { [stnId: string]: -1 | 0 | 1 }) => {\n    branch = branch.filter(stnId => !['linestart', 'lineend'].includes(stnId));\n    let lineMainStns = branch.filter(stnId => stnStates[stnId] >= 0);\n    let linePassStns = branch.filter(stnId => stnStates[stnId] <= 0);\n\n    if (lineMainStns.length === 1) {\n        linePassStns = branch;\n    }\n\n    if (lineMainStns.filter(stnId => linePassStns.indexOf(stnId) !== -1).length === 0 && lineMainStns.length) {\n        // if two set disjoint\n        if (linePassStns[0] === branch[0]) {\n            // -1 -1 1 1\n            linePassStns.push(lineMainStns[0]);\n        } else if (\n            lineMainStns[0] === branch[0] &&\n            lineMainStns[lineMainStns.length - 1] === branch[branch.length - 1] &&\n            linePassStns.length\n        ) {\n            linePassStns = branch;\n            lineMainStns = [];\n        } else {\n            // 1 1 -1 -1\n            linePassStns.unshift(lineMainStns[lineMainStns.length - 1]);\n        }\n    }\n\n    return {\n        main: lineMainStns,\n        pass: linePassStns,\n    };\n};\n","import { ColineInfo, InterchangeInfo } from '../../../constants/constants';\nimport { drawLine } from './share';\n\nexport interface ColineLinePath {\n    main: {\n        linePath: string[];\n        colors: InterchangeInfo[];\n    }[];\n    pass: {\n        linePath: string[];\n        colors: InterchangeInfo[];\n    }[];\n}\n\n/**\n * Return all stations from ColineInfo's `from` and `to` with coline color preserved.\n */\nexport const calculateColineStations = (colineInfoList: ColineInfo[], branches: string[][]) =>\n    colineInfoList\n        .map(coLine => {\n            const involvedBranches = branches.filter(\n                branch => branch.includes(coLine.from) && branch.includes(coLine.to)\n            );\n\n            // the current coLineInfo fall on two separate branches,\n            // which should not be possible in current design.\n            if (involvedBranches.length !== 1) return { linePath: [], colors: coLine.colors };\n\n            const branch = involvedBranches.flat();\n            const a = branch.indexOf(coLine.from);\n            const b = branch.indexOf(coLine.to);\n            const linePath = a < b ? branch.slice(a, b + 1) : branch.slice(b, a + 1);\n            return {\n                linePath: linePath,\n                colors: coLine.colors,\n            };\n        })\n        .filter(branchWithColine => branchWithColine.linePath.length !== 0);\n\n/**\n * Return coline segments with stations in main/pass order.\n */\nexport const calculateColine = (\n    branchWithColine: ReturnType<typeof calculateColineStations>,\n    stnStates: {\n        [stnId: string]: 0 | 1 | -1;\n    }\n) =>\n    branchWithColine\n        .map(branchWithColine => {\n            const linePaths = drawLine(branchWithColine.linePath, stnStates);\n            return {\n                main: [\n                    {\n                        linePath: linePaths.main,\n                        colors: branchWithColine.colors,\n                    },\n                ],\n                pass: [\n                    {\n                        linePath: linePaths.pass,\n                        colors: branchWithColine.colors,\n                    },\n                ],\n            };\n        })\n        // .map(branchWithColine =>\n        //     (\n        //         Object.entries(drawLine(branchWithColine.linePath, stnStates)) as [\n        //             keyof ReturnType<typeof drawLine>,\n        //             string[]\n        //         ][]\n        //     )\n        //         .map(([type, linePath]) => ({ [type]: { linePath: linePath, colors: branchWithColine.colors } }))\n        //         .reduce((acc, cur) => ({ ...acc, ...cur }), { main: [], pass: [] } as ColineLinePath)\n        // )\n        .reduce(\n            (acc, cur) => {\n                acc.main = [...acc.main, ...cur.main];\n                acc.pass = [...acc.pass, ...cur.pass];\n                return acc;\n            },\n            { main: [], pass: [] } as ColineLinePath\n        );\n","import React, { memo, useMemo } from 'react';\nimport { CanvasType, Name, StationDict } from '../../constants/constants';\nimport { useRootSelector } from '../../redux';\nimport { isColineBranch } from '../../redux/param/coline-action';\nimport { calculateColineStations } from '../railmap/methods/shmetro-coline';\nimport SvgWrapper from '../svg-wrapper';\n\nconst LINE_WIDTH = 12;\n\nconst CANVAS_TYPE = CanvasType.RunIn;\n\nconst RunInSHMetro = () => {\n    const { canvasScale } = useRootSelector(state => state.app);\n    const { branches, routes, depsStr: deps } = useRootSelector(store => store.helper);\n    const {\n        svgWidth: svgWidths,\n        svg_height,\n        current_stn_idx,\n        direction,\n        loop,\n        theme,\n    } = useRootSelector(store => store.param);\n\n    const svgWidth = svgWidths[CANVAS_TYPE];\n    // get the height\n    const dh = svg_height - 300;\n\n    const prevStnIds = useMemo(\n        () => {\n            let prevStnIds = routes\n                .filter(route => route.includes(current_stn_idx))\n                .map(route => route[route.indexOf(current_stn_idx) + (direction === 'l' ? 1 : -1)])\n                // .flat()\n                // remove duplicate\n                .reduce((acc, cur) => (acc.includes(cur) ? acc : acc.concat(cur)), [] as string[]);\n            if (\n                loop && // if it is a loop\n                branches[0].includes(current_stn_idx) && // and this station is on the loop line\n                prevStnIds.length === 1 && // and it is the first station of that direction\n                ['linestart', 'lineend'].includes(prevStnIds[0])\n            ) {\n                // get the station from the other end\n                prevStnIds = direction === 'l' ? [branches[0][1]] : [branches[0][branches[0].length - 2]];\n            }\n            return prevStnIds;\n        },\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [deps, current_stn_idx, direction, loop]\n    );\n\n    const nextStnIds = useMemo(\n        () => {\n            let nextStnIds = routes\n                .filter(route => route.includes(current_stn_idx))\n                .map(route => route[route.indexOf(current_stn_idx) + (direction === 'l' ? -1 : 1)])\n                // .flat()\n                // remove duplicate\n                .reduce((acc, cur) => (acc.includes(cur) ? acc : acc.concat(cur)), [] as string[]);\n            if (\n                loop && // if it is a loop\n                branches[0].includes(current_stn_idx) && // and this station is on the loop line\n                nextStnIds.length === 1 && // and it is the last station of that direction\n                ['linestart', 'lineend'].includes(nextStnIds[0])\n            ) {\n                // get the station from the other end\n                nextStnIds = direction === 'l' ? [branches[0][branches[0].length - 2]] : [branches[0][1]];\n            }\n            return nextStnIds;\n        },\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [deps, current_stn_idx, direction, loop]\n    );\n\n    return (\n        <SvgWrapper\n            type={CANVAS_TYPE}\n            svgWidth={svgWidth}\n            svgHeight={svg_height}\n            canvasScale={canvasScale}\n            theme={theme}\n        >\n            <DefsSHMetro />\n            <g transform={`translate(0,${dh})`}>\n                <GeneralStation prevStnIds={prevStnIds} nextStnIds={nextStnIds} />\n            </g>\n        </SvgWrapper>\n    );\n};\n\nexport default RunInSHMetro;\n\nconst DefsSHMetro = memo(() => (\n    <defs>\n        {/* An extension of the line/path. Remember to minus the stroke-width.  */}\n        <marker id=\"slope\" viewBox=\"-1.5 0 3 1.5\" refY={0.5}>\n            <path d=\"M0,0L1,1H-1z\" fill=\"var(--rmg-theme-colour)\" />\n        </marker>\n\n        {/* Outline filter of white pass color in Pujiang Line */}\n        <filter\n            id=\"pujiang_outline_runin\"\n            colorInterpolationFilters=\"sRGB\"\n            // TODO: remove the absolute value while make the filter works correctly\n            filterUnits=\"userSpaceOnUse\"\n            x=\"0\"\n            y=\"-1000\"\n            width=\"5000\"\n            height=\"2000\"\n        >\n            <feMorphology operator=\"erode\" in=\"SourceAlpha\" radius=\"0\" result=\"e1\" />\n            <feMorphology operator=\"erode\" in=\"SourceAlpha\" radius=\"1\" result=\"e2\" />\n            <feComposite in=\"e1\" in2=\"e2\" operator=\"xor\" result=\"outline\" />\n            <feComposite in=\"outline\" in2=\"SourceGraphic\" operator=\"over\" result=\"output\" />\n        </filter>\n    </defs>\n));\n\ninterface RunInGeneralProps {\n    prevStnIds: string[];\n    nextStnIds: string[];\n}\n\nconst GeneralStation = (props: RunInGeneralProps) => {\n    const { prevStnIds, nextStnIds } = props;\n    const { info_panel_type, svgWidth, stn_list } = useRootSelector(store => store.param);\n\n    const middle = svgWidth.runin / 2;\n    const terminal = nextStnIds.length === 1 && ['linestart', 'lineend'].includes(nextStnIds[0]);\n    const original = prevStnIds.length === 1 && ['linestart', 'lineend'].includes(prevStnIds[0]);\n\n    const nextNames = nextStnIds.map(stnId => stn_list[stnId].name);\n    const prevNames = prevStnIds.map(stnId => stn_list[stnId].name);\n\n    const nextBranchLineDy =\n        (nextStnIds.length > 1\n            ? (nextNames[0][0].split('\\\\').length - 1) * -50 + (nextNames[0][1].split('\\\\').length - 1) * -30\n            : 0) + 10;\n    const prevBranchLineDy =\n        (prevStnIds.length > 1\n            ? (prevNames[0][0].split('\\\\').length - 1) * -50 + (prevNames[0][1].split('\\\\').length - 1) * -30\n            : 0) + 10;\n\n    return (\n        <>\n            <BranchLine\n                prevStnIds={prevStnIds}\n                nextStnIds={nextStnIds}\n                nextBranchLineDy={nextBranchLineDy}\n                prevBranchLineDy={prevBranchLineDy}\n            />\n\n            {terminal && info_panel_type !== 'sh2020' ? (\n                <TerminalStation mode=\"terminal\" prevStnIds={prevStnIds} nextStnIds={nextStnIds} />\n            ) : original && info_panel_type !== 'sh2020' ? (\n                <TerminalStation mode=\"original\" prevStnIds={prevStnIds} nextStnIds={nextStnIds} />\n            ) : (\n                <>\n                    {/* General Station */}\n                    <Line prevStnIds={prevStnIds} nextStnIds={nextStnIds} />\n\n                    <g transform={`translate(${middle},160)`} textAnchor=\"middle\">\n                        <CurrentText />\n                    </g>\n                </>\n            )}\n\n            {(original || !terminal) && <NextStn stnIds={props.nextStnIds} />}\n            {(terminal || !original) && <PrevStn stnIds={props.prevStnIds} />}\n        </>\n    );\n};\n\nconst TerminalStation = (props: { mode: 'terminal' | 'original'; prevStnIds: string[]; nextStnIds: string[] }) => {\n    const { mode, prevStnIds, nextStnIds } = props;\n    const { current_stn_idx, theme, svgWidth, direction, coline } = useRootSelector(store => store.param);\n    const { branches } = useRootSelector(store => store.helper);\n\n    const textProps = {\n        l: { original: { x: svgWidth.runin - 36, anchor: 'end' }, terminal: { x: 36, anchor: 'start' } },\n        r: { original: { x: 36, anchor: 'start' }, terminal: { x: svgWidth.runin - 36, anchor: 'end' } },\n    };\n\n    const colineStns = calculateColineStations(Object.values(coline), branches);\n    const nextColineColorFrom = mode === 'terminal' ? prevStnIds : nextStnIds;\n    const nextColineColor =\n        nextStnIds.length > 1\n            ? 'var(--rmg-theme-colour)' // BranchLine will handle color of next line well\n            : colineStns\n                  .filter(co => co.linePath.includes(current_stn_idx) && co.linePath.includes(nextColineColorFrom[0]))\n                  // TODO-coline: handle multiple coline colors\n                  .map(co => co.colors[0][2])[0] ?? 'var(--rmg-theme-colour)';\n\n    return (\n        <>\n            {mode === 'original' && (\n                <path\n                    transform={`translate(0,${coline.length ? '198' : '220'})${coline.length ? 'scale(1,2)' : ''}`}\n                    stroke={nextColineColor}\n                    strokeWidth={12}\n                    d={direction === 'l' ? `M ${svgWidth.runin - 24},16 H 36` : `M24,16 H ${svgWidth.runin - 36}`}\n                    markerEnd=\"url(#slope)\"\n                />\n            )}\n\n            {mode === 'terminal' && (\n                <g filter={theme[2] === '#999999' ? 'url(#pujiang_outline_runin)' : undefined}>\n                    <path\n                        transform={`translate(0,${coline.length ? '198' : '220'})${coline.length ? 'scale(1,2)' : ''}`}\n                        stroke=\"var(--rmg-grey)\"\n                        strokeWidth={12}\n                        d={`M24,16 H ${svgWidth.runin - 24}`}\n                    />\n                </g>\n            )}\n\n            <g\n                transform={`translate(${textProps[direction][mode].x},160)`}\n                textAnchor={textProps[direction][mode].anchor}\n            >\n                <CurrentText />\n            </g>\n        </>\n    );\n};\n\nconst Line = (props: RunInGeneralProps) => {\n    const { prevStnIds, nextStnIds } = props;\n    const {\n        direction,\n        svgWidth,\n        theme,\n        coline,\n        current_stn_idx,\n        stn_list: stnList,\n    } = useRootSelector(store => store.param);\n    const { branches } = useRootSelector(store => store.helper);\n    const middle = svgWidth.runin / 2;\n\n    // determine the end with linestart/lineend or .length === 0\n    const isEnd = (stnIds: string[]) => stnIds.includes('linestart') || stnIds.includes('lineend');\n\n    const colineStns = calculateColineStations(Object.values(coline), branches);\n\n    // whether the next line is single color(var(--rmg-theme-colour) or coline color) or multiple colors\n    // let nextColineMode: 'single' | 'multiple' = 'single';\n    // TODO-coline: if coline is allowed in other segments, then this should be considered more precisely\n    const nextColineMode =\n        nextStnIds.length > 1\n            ? // needs to be single since BranchLine is in effect\n              'single'\n            : isEnd(nextStnIds)\n            ? colineStns.filter(co => [current_stn_idx, prevStnIds[0]].every(stnId => co.linePath.includes(stnId)))\n                  .length > 0\n                ? // if this the terminal station, look back to see if it falls in coline\n                  'multiple'\n                : 'single'\n            : [current_stn_idx, nextStnIds[0]].every(stnId => branches[0].includes(stnId)) && // is in the main line\n              // and has coline from current_stn_idx to nextStnIds[0]\n              colineStns.filter(co => [current_stn_idx, nextStnIds[0]].every(stnId => co.linePath.includes(stnId)))\n                  .length > 0\n            ? 'multiple'\n            : 'single';\n\n    const nextColineColorFrom = isEnd(nextStnIds) ? prevStnIds : nextStnIds;\n    const nextColineColor =\n        nextStnIds.length > 1\n            ? 'var(--rmg-theme-colour)' // BranchLine will handle color of next line well\n            : colineStns\n                  .filter(co => co.linePath.includes(current_stn_idx) && co.linePath.includes(nextColineColorFrom[0]))\n                  // TODO-coline: handle multiple coline colors\n                  .map(co => co.colors[0][2])[0] ?? 'var(--rmg-theme-colour)';\n\n    // curr and next/pass segment is in the coline branch\n    const isInColineBranch = (\n        branches: string[][],\n        current_stn_idx: string,\n        nextOrPassStnIds: string[],\n        stnList: StationDict\n    ) =>\n        branches\n            .slice(1)\n            .filter(branch => [current_stn_idx, nextOrPassStnIds[0]].every(stnId => branch.includes(stnId)))\n            .filter(branch => isColineBranch(branch, stnList)).length > 0;\n\n    // change color to coline color only if it has coline and the curr and next stations are in the coline branch\n    const nextColor =\n        Object.keys(coline).length > 0 && isInColineBranch(branches, current_stn_idx, nextStnIds, stnList)\n            ? nextColineColor\n            : 'var(--rmg-theme-colour)';\n\n    // stretch the next line element if curr and next stations aren't in main line with coline\n    const nextLineStretch =\n        Object.keys(coline).length > 0 &&\n        nextStnIds.length === 1 && // BranchLine will add branch next line so no stretch is needed\n        (isEnd(prevStnIds) || isEnd(nextStnIds)\n            ? true // terminal station with coline(prevent linestart/lineend)\n            : !(\n                  [current_stn_idx, nextStnIds[0]].every(stnId => branches[0].includes(stnId)) &&\n                  colineStns.filter(co => co.linePath.includes(current_stn_idx) && co.linePath.includes(nextStnIds[0]))\n                      .length !== 0\n              )); // no stretch if it is in main line with coline\n\n    // stretch the pass line element if BranchLine is not in effect\n    const passLineStretch = Object.keys(coline).length > 0 && prevStnIds.length === 1;\n\n    return (\n        <g transform=\"translate(0,220)\" strokeWidth={12}>\n            <>\n                {nextColor !== 'var(--rmg-theme-colour)' && (\n                    <marker id={`slope_${nextColor}`} viewBox=\"-1.5 0 3 1.5\" refY={0.5}>\n                        <path d=\"M0,0L1,1H-1z\" fill={nextColor} />\n                    </marker>\n                )}\n                <path\n                    stroke={nextColor}\n                    d={`M ${middle},16 H ${direction === 'l' ? 36 : svgWidth.runin - 36}`}\n                    // markerEnd=\"url(#slope)\"\n                    markerEnd={nextColor === 'var(--rmg-theme-colour)' ? 'url(#slope)' : `url(#slope_${nextColor})`}\n                    transform={nextLineStretch ? 'translate(0,-22)scale(1,2)' : undefined}\n                />\n            </>\n            {nextColineMode === 'multiple' && (\n                <>\n                    <marker id={`slope_${nextColineColor}`} viewBox=\"-1.5 0 3 1.5\" refY={0.5}>\n                        <path d=\"M0,0L1,1H-1z\" fill={nextColineColor} />\n                    </marker>\n                    <path\n                        stroke={nextColineColor}\n                        d={`M ${middle},16 H ${\n                            direction === 'l' ? 36 + LINE_WIDTH : svgWidth.runin - (36 + LINE_WIDTH)\n                        }`}\n                        markerEnd={`url(#slope_${nextColineColor})`}\n                        transform=\"translate(0,-12)\"\n                    />\n                </>\n            )}\n\n            <g\n                filter={theme[2] === '#999999' ? 'url(#pujiang_outline_runin)' : undefined}\n                transform={`translate(0,${passLineStretch ? -22 : 0})scale(1,${passLineStretch ? 2 : 1})`}\n            >\n                <path\n                    stroke=\"var(--rmg-grey)\"\n                    d={`M ${middle},16 H ${direction === 'l' ? svgWidth.runin - 24 : 24} `}\n                />\n            </g>\n        </g>\n    );\n};\n\ninterface RunInBranchLineProps {\n    prevStnIds: string[];\n    nextStnIds: string[];\n    nextBranchLineDy: number;\n    prevBranchLineDy: number;\n}\n\nconst BranchLine = (props: RunInBranchLineProps) => {\n    const { prevStnIds, nextStnIds, nextBranchLineDy, prevBranchLineDy } = props;\n\n    const { direction, svgWidth, current_stn_idx, coline, theme } = useRootSelector(store => store.param);\n    const { branches } = useRootSelector(store => store.helper);\n    const middle = svgWidth.runin / 2;\n\n    const LINE_BRANCH_Y = 125;\n\n    // draw a line between these dots\n    const dotToPos = (dot: [number, number]) => `${dot[0]},${dot[1]}`;\n    const dotsToPath = (dots: [number, number][]) =>\n        `M${dotToPos(dots.at(0)!)} ` +\n        dots\n            .slice(1)\n            .map(dot => `L${dotToPos(dot)}`)\n            .join(' ');\n\n    let nextDots = (\n        direction === 'l'\n            ? [\n                  [svgWidth.runin / 3, LINE_BRANCH_Y],\n                  [svgWidth.runin / 6, nextBranchLineDy],\n                  [36, nextBranchLineDy],\n              ]\n            : [\n                  [(svgWidth.runin / 3) * 2, LINE_BRANCH_Y],\n                  [(svgWidth.runin / 6) * 5, nextBranchLineDy],\n                  [svgWidth.runin - 36, nextBranchLineDy],\n              ]\n    ) as [number, number][];\n    let prevDots = (\n        direction === 'l'\n            ? [\n                  [(svgWidth.runin / 3) * 2, LINE_BRANCH_Y],\n                  [(svgWidth.runin / 6) * 5, prevBranchLineDy],\n                  [svgWidth.runin - 24, prevBranchLineDy],\n              ]\n            : [\n                  [svgWidth.runin / 3, LINE_BRANCH_Y],\n                  [svgWidth.runin / 6, prevBranchLineDy],\n                  [24, prevBranchLineDy],\n              ]\n    ) as [number, number][];\n\n    let nextColor = 'var(--rmg-theme-colour)';\n\n    if (Object.keys(coline).length > 0) {\n        const colineStns = calculateColineStations(Object.values(coline), branches);\n\n        // If the next stns have coline branch here,\n        // uplift branch a little bit with coline color.\n        if (\n            nextStnIds.length > 1 &&\n            colineStns.filter(\n                stns =>\n                    stns.linePath.includes(current_stn_idx) && nextStnIds.some(stnId => stns.linePath.includes(stnId))\n            )\n        ) {\n            // no idea why strokeWidth is 12 but only when dy = -11 will be perfect\n            nextDots[0][1] -= LINE_WIDTH - 1;\n            nextDots.unshift([middle, LINE_BRANCH_Y - LINE_WIDTH + 1]);\n            nextColor = colineStns\n                .filter(\n                    stns =>\n                        stns.linePath.includes(current_stn_idx) &&\n                        nextStnIds.some(stnId => stns.linePath.includes(stnId))\n                )\n                // TODO-coline: known undefined issues when coline is removed if the station is removed via removeInvalidColineOnRemoveStation\n                .at(0)!\n                .colors.at(0)![2];\n        }\n\n        // If the prev stns have coline branch here,\n        // uplift branch a little bit.\n        if (\n            prevStnIds.length > 1 &&\n            colineStns.filter(\n                stns =>\n                    stns.linePath.includes(current_stn_idx) && prevStnIds.some(stnId => stns.linePath.includes(stnId))\n            )\n        ) {\n            // no idea why strokeWidth is 12 but only when dy = -11 will be perfect\n            prevDots[0][1] -= LINE_WIDTH - 1;\n            prevDots.unshift([middle, LINE_BRANCH_Y - LINE_WIDTH + 1]);\n        }\n    }\n\n    return (\n        <g\n            transform=\"translate(0,110)\"\n            strokeWidth={12}\n            fill=\"none\"\n            filter={theme[2] === '#999999' ? 'url(#pujiang_outline_runin)' : undefined}\n        >\n            {/* An extension of the line/path with coline color. */}\n            <marker id=\"slope_branch\" viewBox=\"-1.5 0 3 1.5\" refY={0.5}>\n                <path d=\"M0,0L1,1H-1z\" fill={nextColor} />\n            </marker>\n\n            {nextStnIds.length > 1 && (\n                <path stroke={nextColor} d={dotsToPath(nextDots)} markerEnd=\"url(#slope_branch)\" />\n            )}\n            {prevStnIds.length > 1 && <path stroke=\"var(--rmg-grey)\" d={dotsToPath(prevDots)} />}\n        </g>\n    );\n};\n\nconst CurrentText = () => {\n    const param = useRootSelector(store => store.param);\n    const { name } = param.stn_list[param.current_stn_idx];\n    return useMemo(\n        () => (\n            <>\n                <text className=\"rmg-name__zh\" fontSize={112}>\n                    {name[0].replace('\\\\', '')}\n                </text>\n                <text className=\"rmg-name__en\" fontSize={36} dy={50}>\n                    {name[1].replace('\\\\', '')}\n                </text>\n            </>\n        ),\n        [...name]\n    );\n};\n\nconst NextText = (props: { nextName: Name } & React.SVGProps<SVGGElement>) => {\n    const { nextName, ...others } = props;\n    return (\n        <g {...others}>\n            {useMemo(\n                () => (\n                    <>\n                        {nextName[0].split('\\\\').map((name, i, array) => (\n                            <text\n                                className=\"rmg-name__zh\"\n                                fontSize={48}\n                                key={name}\n                                dy={(array.length - 1 - i) * -50 - (nextName[1].split('\\\\').length - 1) * 30}\n                            >\n                                {name}\n                            </text>\n                        ))}\n                        {nextName[1].split('\\\\').map((name, i, array) => (\n                            <text\n                                className=\"rmg-name__en\"\n                                fontSize={24}\n                                key={name}\n                                dy={28 + (array.length - 1 - i) * -30}\n                            >\n                                {name}\n                            </text>\n                        ))}\n                    </>\n                ),\n                [...nextName]\n            )}\n        </g>\n    );\n};\n\nconst PrevStn = (props: { stnIds: string[] }) => {\n    const param = useRootSelector(store => store.param);\n    const nextNames = props.stnIds.map(stnId => param.stn_list[stnId].name);\n    const prevHintDy =\n        (props.stnIds.length > 1 ? 15 : 125) +\n        nextNames.map(name => name[0].split('\\\\').length).reduce((acc, cur) => acc + cur, -nextNames.length) * -50 +\n        nextNames.map(name => name[1].split('\\\\').length).reduce((acc, cur) => acc + cur, -nextNames.length) * -30;\n    const nextBranchTextDy =\n        (props.stnIds.length > 1\n            ? (nextNames[0][0].split('\\\\').length - 1) * -50 + (nextNames[0][1].split('\\\\').length - 1) * -30\n            : 0) + 70;\n\n    return (\n        <g\n            fill=\"gray\"\n            textAnchor={param.direction === 'l' ? 'end' : 'start'}\n            transform={`translate(${param.direction === 'l' ? param.svgWidth.runin - 36 : 36},0)`}\n        >\n            <NextText nextName={nextNames[0]} transform=\"translate(0,183)\" />\n            {props.stnIds.length > 1 && (\n                <NextText nextName={nextNames[1]} transform={`translate(0,${nextBranchTextDy})`} />\n            )}\n            <g transform={`translate(0, ${prevHintDy})`}>\n                <text className=\"rmg-name__zh\" fontSize={22}>\n                    \n                </text>\n                <text className=\"rmg-name__en\" fontSize={12} dx={param.direction === 'l' ? -70 : 70}>\n                    Past Stop\n                </text>\n            </g>\n        </g>\n    );\n};\n\nconst NextStn = (props: { stnIds: string[] }) => {\n    const param = useRootSelector(store => store.param);\n    const nextNames = props.stnIds.map(stnId => param.stn_list[stnId].name);\n    const nextHintDy =\n        (props.stnIds.length > 1 ? 15 : 125) +\n        nextNames.map(name => name[0].split('\\\\').length).reduce((acc, cur) => acc + cur, -nextNames.length) * -50 +\n        nextNames.map(name => name[1].split('\\\\').length).reduce((acc, cur) => acc + cur, -nextNames.length) * -30;\n    const nextBranchTextDy =\n        (props.stnIds.length > 1\n            ? (nextNames[0][0].split('\\\\').length - 1) * -50 + (nextNames[0][1].split('\\\\').length - 1) * -30\n            : 0) + 70;\n\n    return (\n        <g\n            textAnchor={param.direction === 'l' ? 'start' : 'end'}\n            transform={`translate(${param.direction === 'l' ? 36 : param.svgWidth.runin - 36},0)`}\n        >\n            <NextText nextName={param.stn_list[props.stnIds[0]].name} transform=\"translate(0,183)\" />\n            {props.stnIds.length > 1 && (\n                <NextText\n                    nextName={param.stn_list[props.stnIds[1]].name}\n                    transform={`translate(0,${nextBranchTextDy})`}\n                />\n            )}\n            <g transform={`translate(0, ${nextHintDy})`}>\n                <text className=\"rmg-name__zh\" fontSize={22}>\n                    \n                </text>\n                <text className=\"rmg-name__en\" fontSize={12} dx={param.direction === 'l' ? 70 : -70}>\n                    Next Stop\n                </text>\n            </g>\n        </g>\n    );\n};\n","import { CanvasType, Theme } from '../constants/constants';\nimport React, { ReactNode } from 'react';\n\ninterface SvgWrapperProps {\n    type: CanvasType;\n    svgWidth: number;\n    svgHeight: number;\n    canvasScale: number;\n    theme: Theme;\n    children: ReactNode;\n}\n\nexport default function SvgWrapper(props: SvgWrapperProps) {\n    const { type, svgWidth, svgHeight, canvasScale, theme, children } = props;\n\n    return (\n        <svg\n            id={type}\n            xmlns=\"http://www.w3.org/2000/svg\"\n            xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n            height={svgHeight * canvasScale}\n            viewBox={`0 0 ${svgWidth} ${svgHeight}`}\n            colorInterpolationFilters=\"sRGB\"\n            style={{\n                ['--rmg-svg-width' as any]: svgWidth + 'px',\n                ['--rmg-svg-height' as any]: svgHeight + 'px',\n                ['--rmg-theme-colour' as any]: theme[2],\n                ['--rmg-theme-fg' as any]: theme[3],\n            }}\n        >\n            <rect\n                id=\"canvas-bg\"\n                fill=\"white\"\n                style={{ height: 'var(--rmg-svg-height)', width: 'var(--rmg-svg-width)' }}\n            />\n            {children}\n            <rect\n                id=\"canvas-border\"\n                fill=\"none\"\n                strokeWidth={3}\n                stroke=\"none\"\n                style={{ height: 'var(--rmg-svg-height)', width: 'var(--rmg-svg-width)' }}\n            />\n        </svg>\n    );\n}\n","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}"],"names":["adjacencyList","stnList","leftW","rightW","Object","keys","reduce","acc","cur","children","a","c","criticalPathMethod","from","to","adjMat","len","nodes","allLengths","criticalPaths","forEach","child","cp","push","unshift","maxLength","Math","max","indexOf","getXShareMTR","stnId","branches","criticalPath","includes","branchOfStn","filter","branch","partSource","partSink","leftOpenJaw","lens","slice","getStnState","currentId","routes","direction","console","log","Set","concat","ShortDirection","stnId1","stnId2","route","idx1","idx2","_isSuccessor","_isPredecessor","Stations","data","yShares","xShares","namePoss","leftWideFactor","rightWideFactor","pathTurnParams","branchSpacing","dy_a","tr","sqrt","dy_l","dx_a","dx_l","pathTurnSE","pathTurnNE","this","parents","length","stnPred","res","getYShare","stnIds","lineXs","realXs","realYs","e","prevId","prevY","prevX","path","stnDX","stnExtraH","stnSpareH","warn","x","y","join","replace","stations","drawLine","stnStates","lineMainStns","linePassStns","main","pass","calculateColineStations","colineInfoList","map","coLine","involvedBranches","linePath","colors","flat","b","branchWithColine","calculateColine","linePaths","CANVAS_TYPE","CanvasType","canvasScale","useRootSelector","state","app","store","helper","deps","depsStr","param","svgWidths","svgWidth","svg_height","current_stn_idx","loop","theme","dh","prevStnIds","useMemo","nextStnIds","type","svgHeight","DefsSHMetro","transform","GeneralStation","memo","id","viewBox","refY","d","fill","colorInterpolationFilters","filterUnits","width","height","operator","in","radius","result","in2","props","info_panel_type","stn_list","middle","runin","terminal","original","nextNames","name","prevNames","nextBranchLineDy","split","prevBranchLineDy","BranchLine","TerminalStation","mode","Line","textAnchor","CurrentText","NextStn","PrevStn","coline","textProps","l","anchor","r","colineStns","values","nextColineColorFrom","nextColineColor","co","stroke","strokeWidth","markerEnd","undefined","isEnd","nextColineMode","every","nextColor","nextOrPassStnIds","isColineBranch","isInColineBranch","nextLineStretch","passLineStretch","LINE_BRANCH_Y","dotToPos","dot","dotsToPath","dots","at","nextDots","prevDots","stns","some","LINE_WIDTH","className","fontSize","dy","NextText","nextName","others","i","array","prevHintDy","nextBranchTextDy","dx","nextHintDy","SvgWrapper","xmlns","xmlnsXlink","style","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","F","s","n","done","value","_e","f","TypeError","err","normalCompletion","didErr","call","step","next","_e2"],"sourceRoot":""}