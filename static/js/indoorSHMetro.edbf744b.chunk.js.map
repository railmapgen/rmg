{"version":3,"file":"static/js/indoorSHMetro.edbf744b.chunk.js","mappings":"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","sources":["svgs/indoor/indoor-shmetro.tsx","svgs/mtr/line-diagram-utils.ts","svgs/railmap/methods/mtr.ts"],"sourcesContent":["import React, { memo, useMemo } from 'react';\nimport { adjacencyList, criticalPathMethod, getStnState, getXShareMTR } from '../railmap/methods/share';\nimport StationSHMetro from './station-shmetro';\nimport { StationsSHMetro } from '../railmap/methods/mtr';\nimport { CanvasType, Services, StationDict } from '../../constants/constants';\nimport { useRootSelector } from '../../redux';\nimport LoopSHMetro from '../railmap/main/loop/loop-shmetro';\n\nexport default memo(function IndoorWrapperSHMetro() {\n    const { loop } = useRootSelector(store => store.param);\n    return (\n        <>\n            <DefsSHMetro />\n            {loop ? <LoopSHMetro bank_angle={false} canvas={CanvasType.Indoor} /> : <IndoorSHMetro />}\n            <InfoElements />\n        </>\n    );\n});\n\nexport const DefsSHMetro = React.memo(() => (\n    <defs>\n        <circle id=\"stn_indoor_sh\" fill=\"var(--rmg-white)\" strokeWidth={5} r={8} transform=\"scale(1.5)\" />\n        <path\n            id=\"int2_indoor_sh\"\n            fill=\"var(--rmg-white)\"\n            transform=\"translate(0, -10)scale(2)\"\n            strokeWidth={4}\n            d=\"M -5,0 a 5,5 0 1 1 10,0 V10 a 5,5 0 1 1 -10,0Z\"\n        />\n        <path\n            id=\"express_indoor_sh\"\n            fill=\"var(--rmg-white)\"\n            transform=\"translate(0, -10)scale(2)\"\n            strokeWidth={4}\n            d=\"M -5,0 a 5,5 0 1 1 10,0 V25 a 5,5 0 1 1 -10,0Z\"\n        />\n        <path\n            id=\"direct_indoor_sh\"\n            fill=\"var(--rmg-white)\"\n            transform=\"translate(0, -10)scale(2)\"\n            strokeWidth={4}\n            d=\"M -5,0 a 5,5 0 1 1 10,0 V40 a 5,5 0 1 1 -10,0Z\"\n        />\n    </defs>\n));\n\nconst leftWideFactor = (stnList: StationDict, stnId: string) => {\n    let res = 0;\n    if (stnList[stnId].parents.length === 2) res += 1;\n    if (stnList[stnList[stnId].parents[0]].children.length === 2) res += 1;\n    return res;\n};\n\nconst rightWideFactor = (stnList: StationDict, stnId: string) => {\n    let res = 0;\n    if (stnList[stnId].children.length === 2) res += 1;\n    if (stnList[stnList[stnId].children[0]].parents.length === 2) res += 1;\n    return res;\n};\n\nconst IndoorSHMetro = () => {\n    const { routes, branches, depsStr: deps } = useRootSelector(store => store.helper);\n    const param = useRootSelector(store => store.param);\n\n    const adjMat = adjacencyList(param.stn_list, leftWideFactor, rightWideFactor);\n\n    const criticalPath = criticalPathMethod('linestart', 'lineend', adjMat);\n    const realCP = criticalPathMethod(criticalPath.nodes[1], criticalPath.nodes.slice(-2)[0], adjMat);\n\n    const xShares = React.useMemo(\n        () => {\n            console.log('computing x shares');\n            return Object.keys(param.stn_list).reduce(\n                (acc, cur) => ({ ...acc, [cur]: getXShareMTR(cur, adjMat, branches) }),\n                {} as { [stnId: string]: number }\n            );\n        },\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [branches.toString(), JSON.stringify(adjMat)]\n    );\n    const lineXs: [number, number] = [\n        (param.svgWidth.indoor * param.padding) / 100,\n        param.svgWidth.indoor * (1 - param.padding / 100),\n    ];\n    const xs = Object.keys(xShares).reduce(\n        (acc, cur) => ({ ...acc, [cur]: lineXs[0] + (xShares[cur] / realCP.len) * (lineXs[1] - lineXs[0]) }),\n        {} as typeof xShares\n    );\n\n    const yShares = useMemo(\n        () => StationsSHMetro.getYShares(param.stn_list, branches),\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [deps]\n    );\n    const ys = Object.keys(yShares).reduce(\n        (acc, cur) => ({ ...acc, [cur]: yShares[cur] * param.branch_spacing * 2 }),\n        {} as typeof yShares\n    );\n\n    const stnStates = React.useMemo(\n        () => getStnState(param.current_stn_idx, routes, param.direction),\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [param.current_stn_idx, param.direction, routes.toString()]\n    );\n\n    const servicesAll = Object.values(Services);\n    const servicesPresent = Object.values(param.stn_list)\n        .map(stationInfo => stationInfo.services)\n        .flat() // all services in all stations\n        .reduce(\n            (acc, cur) => {\n                acc[servicesAll.indexOf(cur)] = true;\n                return acc;\n            },\n            [false, false, false] as [boolean, boolean, boolean]\n        ) // set the flag in order\n        .map((bool, i) => [servicesAll[i], bool] as [Services, boolean]) // zip\n        .filter(s => s[1]) // get the existing service\n        .map(s => s[0]); // maintain the services' order\n\n    const linePaths = StationsSHMetro.drawLine(\n        branches,\n        stnStates,\n        param.stn_list,\n        lineXs,\n        xs,\n        ys,\n        param.branch_spacing * 2,\n        criticalPath,\n        0\n    );\n\n    return (\n        <g id=\"main\" transform={`translate(0,${param.svg_height / 2})`}>\n            <Lines paths={linePaths} services={servicesPresent} />\n            <StationGroup xs={xs} ys={ys} services={servicesPresent} />\n        </g>\n    );\n};\n\nconst Lines = (props: { paths: { main: string[]; pass: string[] }; services: Services[] }) => {\n    return (\n        <g fill=\"none\" strokeWidth={12} stroke=\"var(--rmg-theme-colour)\">\n            {props.services.map((service, i) => (\n                <g key={`indoor_line_${i}`} transform={`translate(0, ${i * 30})`}>\n                    {props.paths.main.map((path, i) => (\n                        <path key={i} d={path} />\n                    ))}\n                    {props.paths.pass.map((path, i) => (\n                        <path key={i} d={path} />\n                    ))}\n                </g>\n            ))}\n        </g>\n    );\n};\n\ninterface StationGroupProps {\n    xs: { [stnId: string]: number };\n    ys: { [stnId: string]: number };\n    services: Services[]; // determine if all station text should be upward\n}\n\nconst StationGroup = (props: StationGroupProps) => {\n    const { branches } = useRootSelector(store => store.helper);\n    const param = useRootSelector(store => store.param);\n    const { xs, ys, services } = props;\n\n    return (\n        <g>\n            {Object.keys(param.stn_list)\n                .filter(stnId => !['linestart', 'lineend'].includes(stnId))\n                .filter(stnId => param.stn_list[stnId].services.length !== 0)\n                .map(stnId => (\n                    <g key={stnId} transform={`translate(${xs[stnId]},${ys[stnId]})`}>\n                        <StationSHMetro\n                            stnId={stnId}\n                            nameDirection={\n                                branches\n                                    .filter(branch => branch.includes(stnId))\n                                    .map(branch =>\n                                        branch.indexOf(stnId) % 2 === 0 || services.length > 1 ? 'downward' : 'upward'\n                                    )[0] as 'upward' | 'downward'\n                            }\n                            services={services}\n                        />\n                    </g>\n                ))}\n        </g>\n    );\n};\n\nconst InfoElements = () => {\n    const param = useRootSelector(store => store.param);\n\n    return React.useMemo(\n        () => (\n            <>\n                <g transform={`translate(${param.svgWidth.indoor / 2},50)`}>\n                    <text textAnchor=\"middle\" fontSize=\"30\" className=\"rmg-name__zh\">\n                        轨道交通{param.line_name[0]}运营线路示意图\n                    </text>\n                </g>\n                <g transform={`translate(${param.svgWidth.indoor / 2},${param.svg_height - 270})`}>\n                    <text textAnchor=\"middle\" fontSize=\"18\" className=\"rmg-name__zh\" dx=\"-30\" dy=\"230\">\n                        友情提示：请留意您需要换乘线路的首末班时间，以免耽误您的出行，末班车进站前三分钟停售该末班车车票。\n                    </text>\n                    <text textAnchor=\"middle\" fontSize=\"12\" className=\"rmg-name__en\" dx=\"10\" dy=\"250\">\n                        Please pay attention to the interchange schedule if you want to transfer to other lines. Stop\n                        selling tickets 3 minutes before the last train services.\n                    </text>\n                    <g transform=\"translate(-600,215)\">\n                        <rect x=\"-5\" y=\"-25\" width=\"100\" height=\"70\" fill=\"none\" stroke=\"black\" rx=\"5\"></rect>\n                        <line x1=\"28\" x2=\"28\" y1=\"-20\" y2=\"40\" stroke=\"black\"></line>\n                        <text className=\"rmg-name__zh\" dx=\"3\" fontSize=\"18\">\n                            图\n                        </text>\n                        <text className=\"rmg-name__zh\" dx=\"3\" dy=\"18\" fontSize=\"18\">\n                            例\n                        </text>\n                        <text className=\"rmg-name__en\" dy=\"35\" fontSize=\"8\">\n                            legend\n                        </text>\n                        <use\n                            transform=\"translate(45,10)\"\n                            xlinkHref=\"#int2_indoor_sh\"\n                            stroke=\"var(--rmg-theme-colour)\"\n                        />\n                        <text className=\"rmg-name__zh\" dx=\"60\" dy=\"10\" fontSize=\"10\">\n                            换乘站\n                        </text>\n                        <text className=\"rmg-name__en\" dx=\"60\" dy=\"20\" fontSize=\"6\">\n                            Interchange\n                        </text>\n                        <text className=\"rmg-name__en\" dx=\"60\" dy=\"30\" fontSize=\"6\">\n                            Station\n                        </text>\n                    </g>\n                </g>\n            </>\n        ),\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [param.svgWidth.indoor, param.svg_height, param.line_name]\n    );\n};\n\n/* Some unused functions to split branches from the main line.\n * Note the branches here has a slightly different meaning.\n * It refers to all the line sections that have a parallel line\n * rather than the upper or the bottom branch section.\n *\n * Currently these functions only can be used on a line that\n * branches in the middle and ends at the linestart, which also\n * means that linestart has two children in the adjMat.\n */\n/*\nconst getPathLength = (adjMat: ReturnType<typeof adjacencyList>, from: string, to: string): number => {\n    let cnt = 0, cur = from\n    while (Object.keys(adjMat[cur]).length > 0) {\n        cnt += 1\n        // we choose the first for all the cases so that the length for different branches will end in the same node\n        cur = Object.keys(adjMat[cur])[0]\n    }\n    return cnt\n}\nconst getIntersectionStn = (adjMat: ReturnType<typeof adjacencyList>) => {\n    const start = Object.keys(adjMat['linestart'])\n\n    let a = start[0], b = start[1]\n    const lenA = getPathLength(adjMat, a, 'lineend')\n    const lenB = getPathLength(adjMat, b, 'lineend')\n    if (lenA < lenB) {\n        for (let i = 0; i < lenB - lenA; i++) b = Object.keys(adjMat[b])[0]\n    } else {\n        for (let i = 0; i < lenA - lenB; i++) a = Object.keys(adjMat[a])[0]\n    }\n    while (a !== b) {\n        a = Object.keys(adjMat[a])[0]\n        b = Object.keys(adjMat[b])[0]\n    }\n    return a\n}\nconst getBranchesAndMainLine = (adjMat: ReturnType<typeof adjacencyList>) => {\n    const start = Object.keys(adjMat['linestart'])\n    const intersection = getIntersectionStn(adjMat)\n    return {\n        'branches': [\n            criticalPathMethod(start[0], intersection, adjMat).nodes,\n            criticalPathMethod(start[1], intersection, adjMat).nodes\n        ],\n        'main': criticalPathMethod(intersection, 'lineend', adjMat).nodes\n    }\n}\nconst getYShares = (adjMat: ReturnType<typeof adjacencyList>,\n    branchesAndMainLine: ReturnType<typeof getBranchesAndMainLine>,\n    stnId: string) => {\n    const branches = branchesAndMainLine.branches\n    const main = branchesAndMainLine.main\n\n    if (main.includes(stnId)) {\n        return 3\n    } else if (branches[0].includes(stnId)) {\n        return 0\n    } else {\n        return 6\n    }\n}\n*/\n","import { StationDict } from '../../constants/constants';\n\n/**\n * @return - negative: above main line, positive: below main line\n */\nexport const getStationYShare = (stationId: string, branches: string[][], stationList: StationDict): number => {\n    const mainBranch = branches[0];\n\n    if (mainBranch.includes(stationId)) {\n        // on main branch\n        if (branches.slice(1).find(branch => branch.includes(stationId))) {\n            // node shared by multiple branches\n            return 0;\n        } else {\n            const openJawSiblingBranch = branches.slice(1).find(branch => {\n                const isLeftOpenJaw = branch[0] === 'linestart';\n                const hasSiblingBranchOpenJawOnTheLeft =\n                    mainBranch.indexOf(stationId) < mainBranch.indexOf(branch.slice(-1)[0]);\n\n                const isRightOpenJaw = branch.slice(-1)[0] === 'lineend';\n                const hasSiblingBranchOpenJawOnTheRight = mainBranch.indexOf(stationId) > mainBranch.indexOf(branch[0]);\n\n                return (\n                    (isLeftOpenJaw && hasSiblingBranchOpenJawOnTheLeft) ||\n                    (isRightOpenJaw && hasSiblingBranchOpenJawOnTheRight)\n                );\n            });\n\n            if (openJawSiblingBranch) {\n                // on main branch but open jaw\n                // NOTE: determine y share of node by children ordering, not by whether it's a branch or not (like GZMTR)\n                // TODO: Remove requirement on stationList arg\n                return stationList[openJawSiblingBranch[0]].children.indexOf(openJawSiblingBranch[1]) === 1 ? -1 : 1;\n            } else {\n                // pure main branch without siblings or main branch with sidings\n                return 0;\n            }\n        }\n    } else {\n        // on branch/sidings\n        const branchBelongsTo = branches.slice(1).find(branch => branch.includes(stationId));\n        if (branchBelongsTo) {\n            const isSiding = branchBelongsTo[0] !== 'linestart' && branchBelongsTo.slice(-1)[0] !== 'lineend';\n            if (isSiding) {\n                return stationList[branchBelongsTo[0]].children.indexOf(branchBelongsTo[1]) === 1 ? 1.2 : -1.2;\n            } else {\n                return stationList[branchBelongsTo[0]].children.indexOf(branchBelongsTo[1]) === 1 ? 1 : -1;\n            }\n        } else {\n            // fallback\n            return 0;\n        }\n    }\n};\n\nexport const getSidingPath = (coords: [number, number][]): string => {\n    const TURNING_RADIUS = 6;\n    const RIGHT_DOWN_ARC = `a${TURNING_RADIUS},${TURNING_RADIUS},0,0,1,${TURNING_RADIUS},${TURNING_RADIUS}`;\n    const DOWN_RIGHT_ARC = `a${TURNING_RADIUS},${TURNING_RADIUS},0,0,0,${TURNING_RADIUS},${TURNING_RADIUS}`;\n    const RIGHT_UP_ARC = `a${TURNING_RADIUS},${TURNING_RADIUS},0,0,0,${TURNING_RADIUS},-${TURNING_RADIUS}`;\n    const UP_RIGHT_ARC = `a${TURNING_RADIUS},${TURNING_RADIUS},0,0,1,${TURNING_RADIUS},-${TURNING_RADIUS}`;\n\n    let prevCoord: [number, number] | undefined;\n    let paths: string[] = [];\n\n    for (let coord of coords) {\n        if (!prevCoord) {\n            paths.push('M' + coord.join(','));\n        } else {\n            if (coord[1] === prevCoord[1]) {\n                // horizontal\n                paths.push('H' + coord[0]);\n            } else {\n                const midPointX = (coord[0] + prevCoord[0]) / 2 - (prevCoord[1] === 0 ? 0 : TURNING_RADIUS * 2);\n                paths.push('H' + midPointX);\n\n                if (coord[1] > prevCoord[1]) {\n                    // turn to below\n                    paths.push(RIGHT_DOWN_ARC);\n                    paths.push('V' + (coord[1] - TURNING_RADIUS));\n                    paths.push(DOWN_RIGHT_ARC);\n                } else {\n                    // turn to above\n                    paths.push(RIGHT_UP_ARC);\n                    paths.push('V' + (coord[1] + TURNING_RADIUS));\n                    paths.push(UP_RIGHT_ARC);\n                }\n\n                paths.push('H' + coord[0]);\n            }\n        }\n        // update prev coordinate\n        prevCoord = coord;\n    }\n\n    return paths.join(' ').replace(/( H([\\d.]+))+/g, ' H$2');\n};\n","import { Stations } from './share';\nimport { StationDict, StationInfo } from '../../../constants/constants';\nimport { getSidingPath } from '../../mtr/line-diagram-utils';\n\nexport const leftWideFactor = (stnList: StationDict, stnId: string) => {\n    var res = 0;\n    let { transfer } = stnList[stnId];\n    let ls = transfer.info.map(val => val.length);\n    if (transfer.tick_direc === 'l') {\n        // int3 or above\n        if (!ls[1] && ls[0] > 1) res += 0.8;\n        // osi except osi22\n        if (ls[1] && (ls[0] !== 1 || ls[1] !== 2)) res += 0.8;\n    }\n    if (ls[0] === 1 && ls[1] === 2) {\n        // osi22 not end\n        if (stnList[stnId].parents[0] !== 'linestart' && stnList[stnId].children[0] !== 'lineend') res += 0.8;\n    }\n    // let { type, tick_direc } = stnList[stnId].transfer;\n    // if (tick_direc === 'l' && ['int3', 'osi11', 'osi12', 'osi21', 'osi31'].includes(type)) res += 0.8;\n    if (stnList[stnId].parents.length === 2) res += 0.2;\n    if (stnList[stnList[stnId].parents[0]].children.length === 2) res += 0.4;\n    return res;\n};\n\nexport const rightWideFactor = (stnList: StationDict, stnId: string) => {\n    var res = 0;\n    let { transfer } = stnList[stnId];\n    let ls = transfer.info.map(val => val.length);\n    if (transfer.tick_direc === 'r') {\n        // int3 or above\n        if (!ls[1] && ls[0] > 1) res += 0.8;\n        // osi except osi22\n        if (ls[1] && (ls[0] !== 1 || ls[1] !== 2)) res += 0.8;\n    }\n    if (ls[0] === 1 && ls[1] === 2) {\n        if (stnList[stnId].parents[0] !== 'linestart' && stnList[stnId].children[0] !== 'lineend') res += 0.8;\n    }\n    // let { type, tick_direc } = stnList[stnId].transfer;\n    // if (tick_direc === 'r' && ['int3', 'osi11', 'osi12', 'osi21', 'osi31'].includes(type)) res += 0.8;\n    if (stnList[stnId].children.length === 2) res += 0.2;\n    if (stnList[stnList[stnId].children[0]].parents.length === 2) res += 0.4;\n    return res;\n};\n\nexport class StationsMTR extends Stations {\n    protected leftWideFactor = (stnId: string) => {\n        return leftWideFactor(this.stnList, stnId);\n    };\n\n    protected rightWideFactor = (stnId: string) => {\n        return rightWideFactor(this.stnList, stnId);\n    };\n\n    static drawLine(\n        branches: string[][],\n        stnStates: { [stnId: string]: -1 | 0 | 1 },\n        stnList: { [stnId: string]: StationInfo },\n        lineXs: [number, number],\n        xs: { [stnId: string]: number },\n        ys: { [stnId: string]: number },\n        branchSpacing: number,\n        cp: { len: number; nodes: string[] },\n        e: number = 0\n    ) {\n        let linePaths = {\n            main: [] as string[],\n            pass: [] as string[],\n            sidingMain: [] as string[],\n            sidingPass: [] as string[],\n        };\n\n        branches.forEach((branch, i) => {\n            const isSiding = branch[0] !== 'linestart' && branch.slice(-1)[0] !== 'lineend';\n\n            branch = branch.filter(stnId => !['linestart', 'lineend'].includes(stnId));\n            var lineMainStns = branch.filter(stnId => stnStates[stnId] >= 0);\n            var linePassStns = branch.filter(stnId => stnStates[stnId] <= 0);\n\n            if (lineMainStns.length === 1) {\n                linePassStns = branch;\n            }\n\n            if (lineMainStns.filter(stnId => linePassStns.indexOf(stnId) !== -1).length === 0 && lineMainStns.length) {\n                // if two set disjoint\n                if (linePassStns[0] === branch[0]) {\n                    // -1 -1 1 1\n                    linePassStns.push(lineMainStns[0]);\n                } else if (\n                    lineMainStns[0] === branch[0] &&\n                    lineMainStns[lineMainStns.length - 1] === branch[branch.length - 1] &&\n                    linePassStns.length\n                ) {\n                    linePassStns = branch;\n                    lineMainStns = [];\n                } else {\n                    // 1 1 -1 -1\n                    linePassStns.unshift(lineMainStns[lineMainStns.length - 1]);\n                }\n            }\n\n            if (isSiding) {\n                linePaths.sidingMain.push(getSidingPath(lineMainStns.map(id => [xs[id], ys[id]])));\n                linePaths.sidingPass.push(getSidingPath(linePassStns.map(id => [xs[id], ys[id]])));\n            } else {\n                linePaths.main.push(\n                    new this({ stnList, criticalPath: cp })._linePath(\n                        lineMainStns,\n                        lineXs,\n                        branches,\n                        xs,\n                        ys,\n                        branchSpacing,\n                        cp,\n                        e\n                    )\n                );\n                linePaths.pass.push(\n                    new this({ stnList, criticalPath: cp })._linePath(\n                        linePassStns,\n                        lineXs,\n                        branches,\n                        xs,\n                        ys,\n                        branchSpacing,\n                        cp,\n                        e\n                    )\n                );\n            }\n        });\n\n        return linePaths;\n    }\n}\n\nexport class StationsSHMetro extends StationsMTR {\n    static drawLine(\n        branches: string[][],\n        stnStates: { [stnId: string]: -1 | 0 | 1 },\n        stnList: { [stnId: string]: StationInfo },\n        lineXs: [number, number],\n        xs: { [stnId: string]: number },\n        ys: { [stnId: string]: number },\n        branchSpacing: number,\n        cp: { len: number; nodes: string[] },\n        e: number = 0\n    ) {\n        let linePaths = {\n            main: [] as string[],\n            pass: [] as string[],\n            sidingMain: [] as string[],\n            sidingPass: [] as string[],\n        };\n\n        branches.forEach((branch, i) => {\n            branch = branch.filter(stnId => !['linestart', 'lineend'].includes(stnId));\n            var lineMainStns = branch.filter(stnId => stnStates[stnId] >= 0);\n            var linePassStns = branch.filter(stnId => stnStates[stnId] <= 0);\n\n            if (lineMainStns.length === 1) {\n                linePassStns = branch;\n            }\n\n            if (lineMainStns.filter(stnId => linePassStns.indexOf(stnId) !== -1).length === 0 && lineMainStns.length) {\n                // if two set disjoint\n                if (linePassStns[0] === branch[0]) {\n                    // -1 -1 1 1\n                    linePassStns.push(lineMainStns[0]);\n                } else if (\n                    lineMainStns[0] === branch[0] &&\n                    lineMainStns[lineMainStns.length - 1] === branch[branch.length - 1] &&\n                    linePassStns.length\n                ) {\n                    linePassStns = branch;\n                    lineMainStns = [];\n                } else {\n                    // 1 1 -1 -1\n                    linePassStns.unshift(lineMainStns[lineMainStns.length - 1]);\n                }\n            }\n\n            linePaths.main.push(\n                new this({ stnList, criticalPath: cp })._linePath(\n                    lineMainStns,\n                    lineXs,\n                    branches,\n                    xs,\n                    ys,\n                    branchSpacing,\n                    cp,\n                    e\n                )\n            );\n            linePaths.pass.push(\n                new this({ stnList, criticalPath: cp })._linePath(\n                    linePassStns,\n                    lineXs,\n                    branches,\n                    xs,\n                    ys,\n                    branchSpacing,\n                    cp,\n                    e\n                )\n            );\n        });\n\n        return linePaths;\n    }\n}\n"],"names":["memo","loop","useRootSelector","store","param","DefsSHMetro","bank_angle","canvas","CanvasType","IndoorSHMetro","InfoElements","React","id","fill","strokeWidth","r","transform","d","leftWideFactor","stnList","stnId","res","parents","length","children","rightWideFactor","helper","routes","branches","deps","depsStr","adjMat","adjacencyList","stn_list","criticalPath","criticalPathMethod","realCP","nodes","slice","xShares","console","log","Object","keys","reduce","acc","cur","getXShareMTR","toString","JSON","stringify","lineXs","svgWidth","indoor","padding","xs","len","yShares","useMemo","StationsSHMetro","ys","branch_spacing","stnStates","getStnState","current_stn_idx","direction","servicesAll","values","Services","servicesPresent","map","stationInfo","services","flat","indexOf","bool","i","filter","s","linePaths","svg_height","Lines","paths","StationGroup","props","stroke","service","main","path","pass","includes","nameDirection","branch","textAnchor","fontSize","className","line_name","dx","dy","x","y","width","height","rx","x1","x2","y1","y2","xlinkHref","getStationYShare","stationId","stationList","mainBranch","find","openJawSiblingBranch","isLeftOpenJaw","hasSiblingBranchOpenJawOnTheLeft","isRightOpenJaw","hasSiblingBranchOpenJawOnTheRight","branchBelongsTo","getSidingPath","coords","prevCoord","RIGHT_DOWN_ARC","DOWN_RIGHT_ARC","RIGHT_UP_ARC","UP_RIGHT_ARC","coord","push","midPointX","TURNING_RADIUS","join","replace","transfer","ls","info","val","tick_direc","StationsMTR","branchSpacing","cp","e","sidingMain","sidingPass","forEach","isSiding","lineMainStns","linePassStns","unshift","_linePath","Stations"],"sourceRoot":""}